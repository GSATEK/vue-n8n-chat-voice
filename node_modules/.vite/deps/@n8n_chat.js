import {
  Fragment,
  Transition,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  readonly,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  toRefs,
  unref,
  vModelText,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-U3LI7FBV.js";

// node_modules/@n8n/chat/dist/chat.es.js
var Fe = {
  webhookUrl: "http://localhost:5678",
  webhookConfig: {
    method: "POST",
    headers: {}
  },
  target: "#n8n-chat",
  mode: "window",
  loadPreviousSession: true,
  chatInputKey: "chatInput",
  chatSessionKey: "sessionId",
  defaultLanguage: "en",
  showWelcomeScreen: false,
  initialMessages: ["Hi there! 👋", "My name is Nathan. How can I assist you today?"],
  i18n: {
    en: {
      title: "Hi there! 👋",
      subtitle: "Start a chat. We're here to help you 24/7.",
      footer: "",
      getStarted: "New Conversation",
      inputPlaceholder: "Type your question..",
      closeButtonTooltip: "Close chat"
    }
  },
  theme: {}
};
var Mo = "#n8n-chat";
var Io = "n8n-chat";
var ht = `${Io}/sessionId`;
var fr = "Chat";
var pr = "ChatOptions";
var X = [];
for (wn = 0; wn < 256; ++wn)
  X.push((wn + 256).toString(16).slice(1));
var wn;
function Oo(n, e = 0) {
  return (X[n[e + 0]] + X[n[e + 1]] + X[n[e + 2]] + X[n[e + 3]] + "-" + X[n[e + 4]] + X[n[e + 5]] + "-" + X[n[e + 6]] + X[n[e + 7]] + "-" + X[n[e + 8]] + X[n[e + 9]] + "-" + X[n[e + 10]] + X[n[e + 11]] + X[n[e + 12]] + X[n[e + 13]] + X[n[e + 14]] + X[n[e + 15]]).toLowerCase();
}
var Je;
var Fo = new Uint8Array(16);
function Bo() {
  if (!Je && (Je = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Je))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Je(Fo);
}
var Po = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var dt = {
  randomUUID: Po
};
function Be(n, e, t) {
  if (dt.randomUUID && !e && !n)
    return dt.randomUUID();
  n = n || {};
  var r = n.random || (n.rng || Bo)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, Oo(r);
}
async function $o() {
  return "";
}
async function Vn(...n) {
  var s, i;
  const e = await $o(), t = (s = n[1]) == null ? void 0 : s.body, r = {
    ...e ? { authorization: `Bearer ${e}` } : {},
    ...(i = n[1]) == null ? void 0 : i.headers
  };
  return t instanceof FormData ? delete r["Content-Type"] : r["Content-Type"] = "application/json", await (await fetch(n[0], {
    ...n[1],
    mode: "cors",
    cache: "no-cache",
    headers: r
  })).json();
}
async function hr(n, e = {}, t = {}) {
  let r = n;
  return Object.keys(e).length > 0 && (r = `${r}?${new URLSearchParams(
    e
  ).toString()}`), await Vn(r, { ...t, method: "GET" });
}
async function dr(n, e = {}, t = {}) {
  return await Vn(n, {
    ...t,
    method: "POST",
    body: JSON.stringify(e)
  });
}
async function zo(n, e = {}, t = [], r = {}) {
  const o = new FormData();
  for (const s in e)
    o.append(s, e[s]);
  for (const s of t)
    o.append("files", s);
  return await Vn(n, {
    ...r,
    method: "POST",
    body: o
  });
}
async function Uo(n, e) {
  var r, o;
  return await (((r = e.webhookConfig) == null ? void 0 : r.method) === "POST" ? dr : hr)(
    `${e.webhookUrl}`,
    {
      action: "loadPreviousSession",
      [e.chatSessionKey]: n,
      ...e.metadata ? { metadata: e.metadata } : {}
    },
    {
      headers: (o = e.webhookConfig) == null ? void 0 : o.headers
    }
  );
}
async function Ho(n, e, t, r) {
  var s, i, c;
  return e.length > 0 ? await zo(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    e,
    {
      headers: (s = r.webhookConfig) == null ? void 0 : s.headers
    }
  ) : await (((i = r.webhookConfig) == null ? void 0 : i.method) === "POST" ? dr : hr)(
    `${r.webhookUrl}`,
    {
      action: "sendMessage",
      [r.chatSessionKey]: t,
      [r.chatInputKey]: n,
      ...r.metadata ? { metadata: r.metadata } : {}
    },
    {
      headers: (c = r.webhookConfig) == null ? void 0 : c.headers
    }
  );
}
function Vo() {
  const n = /* @__PURE__ */ new Map();
  function e(o, s) {
    const i = n.get(o);
    i && i.splice(i.indexOf(s) >>> 0, 1);
  }
  function t(o, s) {
    let i = n.get(o);
    return i ? i.push(s) : i = [s], n.set(o, i), () => e(o, s);
  }
  function r(o, s) {
    const i = n.get(o);
    i && i.slice().forEach(async (c) => {
      await c(s);
    });
  }
  return {
    on: t,
    off: e,
    emit: r
  };
}
function Go(n) {
  if (!document.querySelector(n)) {
    const t = document.createElement("div");
    n.startsWith("#") && (t.id = n.replace("#", "")), n.startsWith(".") && t.classList.add(n.replace(".", "")), document.body.appendChild(t);
  }
}
var re = Vo();
var jo = {
  install(n, e) {
    n.provide(pr, e);
    const t = ref([]), r = ref(null), o = ref(false), s = computed(
      () => (e.initialMessages ?? []).map((u) => ({
        id: Be(),
        text: u,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      }))
    );
    async function i(u, p = []) {
      const f = {
        id: Be(),
        text: u,
        sender: "user",
        files: p,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(f), o.value = true, nextTick(() => {
        re.emit("scrollToBottom");
      });
      const h5 = await Ho(
        u,
        p,
        r.value,
        e
      );
      let d = h5.output ?? h5.text ?? "";
      if (d === "" && Object.keys(h5).length > 0)
        try {
          d = JSON.stringify(h5, null, 2);
        } catch {
        }
      const g = {
        id: Be(),
        text: d,
        sender: "bot",
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      t.value.push(g), o.value = false, nextTick(() => {
        re.emit("scrollToBottom");
      });
    }
    async function c() {
      if (!e.loadPreviousSession)
        return;
      const u = localStorage.getItem(ht) ?? Be(), p = await Uo(u, e), f = (/* @__PURE__ */ new Date()).toISOString();
      return t.value = ((p == null ? void 0 : p.data) || []).map((h5, d) => ({
        id: `${d}`,
        text: h5.kwargs.content,
        sender: h5.id.includes("HumanMessage") ? "user" : "bot",
        createdAt: f
      })), t.value.length && (r.value = u), u;
    }
    async function a() {
      r.value = Be(), localStorage.setItem(ht, r.value);
    }
    const l = {
      initialMessages: s,
      messages: t,
      currentSessionId: r,
      waitingForResponse: o,
      loadPreviousSession: c,
      startNewSession: a,
      sendMessage: i
    };
    n.provide(fr, l), n.config.globalProperties.$chat = l;
  }
};
function Gn(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Zo(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(n).forEach(function(r) {
    var o = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, o.get ? o : {
      enumerable: true,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
function gr(n) {
  return n instanceof Map ? n.clear = n.delete = n.set = function() {
    throw new Error("map is read-only");
  } : n instanceof Set && (n.add = n.clear = n.delete = function() {
    throw new Error("set is read-only");
  }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach((e) => {
    const t = n[e], r = typeof t;
    (r === "object" || r === "function") && !Object.isFrozen(t) && gr(t);
  }), n;
}
var gt = class {
  /**
   * @param {CompiledMode} mode
   */
  constructor(e) {
    e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = false;
  }
  ignoreMatch() {
    this.isMatchIgnored = true;
  }
};
function mr(n) {
  return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
}
function ke(n, ...e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r in n)
    t[r] = n[r];
  return e.forEach(function(r) {
    for (const o in r)
      t[o] = r[o];
  }), /** @type {T} */
  t;
}
var Ko = "</span>";
var mt = (n) => !!n.scope;
var Wo = (n, { prefix: e }) => {
  if (n.startsWith("language:"))
    return n.replace("language:", "language-");
  if (n.includes(".")) {
    const t = n.split(".");
    return [
      `${e}${t.shift()}`,
      ...t.map((r, o) => `${r}${"_".repeat(o + 1)}`)
    ].join(" ");
  }
  return `${e}${n}`;
};
var Yo = class {
  /**
   * Creates a new HTMLRenderer
   *
   * @param {Tree} parseTree - the parse tree (must support `walk` API)
   * @param {{classPrefix: string}} options
   */
  constructor(e, t) {
    this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this);
  }
  /**
   * Adds texts to the output stream
   *
   * @param {string} text */
  addText(e) {
    this.buffer += mr(e);
  }
  /**
   * Adds a node open to the output stream (if needed)
   *
   * @param {Node} node */
  openNode(e) {
    if (!mt(e))
      return;
    const t = Wo(
      e.scope,
      { prefix: this.classPrefix }
    );
    this.span(t);
  }
  /**
   * Adds a node close to the output stream (if needed)
   *
   * @param {Node} node */
  closeNode(e) {
    mt(e) && (this.buffer += Ko);
  }
  /**
   * returns the accumulated buffer
  */
  value() {
    return this.buffer;
  }
  // helpers
  /**
   * Builds a span element
   *
   * @param {string} className */
  span(e) {
    this.buffer += `<span class="${e}">`;
  }
};
var _t = (n = {}) => {
  const e = { children: [] };
  return Object.assign(e, n), e;
};
var jn = class _jn {
  constructor() {
    this.rootNode = _t(), this.stack = [this.rootNode];
  }
  get top() {
    return this.stack[this.stack.length - 1];
  }
  get root() {
    return this.rootNode;
  }
  /** @param {Node} node */
  add(e) {
    this.top.children.push(e);
  }
  /** @param {string} scope */
  openNode(e) {
    const t = _t({ scope: e });
    this.add(t), this.stack.push(t);
  }
  closeNode() {
    if (this.stack.length > 1)
      return this.stack.pop();
  }
  closeAllNodes() {
    for (; this.closeNode(); )
      ;
  }
  toJSON() {
    return JSON.stringify(this.rootNode, null, 4);
  }
  /**
   * @typedef { import("./html_renderer").Renderer } Renderer
   * @param {Renderer} builder
   */
  walk(e) {
    return this.constructor._walk(e, this.rootNode);
  }
  /**
   * @param {Renderer} builder
   * @param {Node} node
   */
  static _walk(e, t) {
    return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach((r) => this._walk(e, r)), e.closeNode(t)), e;
  }
  /**
   * @param {Node} node
   */
  static _collapse(e) {
    typeof e != "string" && e.children && (e.children.every((t) => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach((t) => {
      _jn._collapse(t);
    }));
  }
};
var Jo = class extends jn {
  /**
   * @param {*} options
   */
  constructor(e) {
    super(), this.options = e;
  }
  /**
   * @param {string} text
   */
  addText(e) {
    e !== "" && this.add(e);
  }
  /** @param {string} scope */
  startScope(e) {
    this.openNode(e);
  }
  endScope() {
    this.closeNode();
  }
  /**
   * @param {Emitter & {root: DataNode}} emitter
   * @param {string} name
   */
  __addSublanguage(e, t) {
    const r = e.root;
    t && (r.scope = `language:${t}`), this.add(r);
  }
  toHTML() {
    return new Yo(this, this.options).value();
  }
  finalize() {
    return this.closeAllNodes(), true;
  }
};
function Ue(n) {
  return n ? typeof n == "string" ? n : n.source : null;
}
function _r(n) {
  return De("(?=", n, ")");
}
function Xo(n) {
  return De("(?:", n, ")*");
}
function Qo(n) {
  return De("(?:", n, ")?");
}
function De(...n) {
  return n.map((t) => Ue(t)).join("");
}
function es(n) {
  const e = n[n.length - 1];
  return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {};
}
function Zn(...n) {
  return "(" + (es(n).capture ? "" : "?:") + n.map((r) => Ue(r)).join("|") + ")";
}
function br(n) {
  return new RegExp(n.toString() + "|").exec("").length - 1;
}
function ns(n, e) {
  const t = n && n.exec(e);
  return t && t.index === 0;
}
var ts = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
function Kn(n, { joinWith: e }) {
  let t = 0;
  return n.map((r) => {
    t += 1;
    const o = t;
    let s = Ue(r), i = "";
    for (; s.length > 0; ) {
      const c = ts.exec(s);
      if (!c) {
        i += s;
        break;
      }
      i += s.substring(0, c.index), s = s.substring(c.index + c[0].length), c[0][0] === "\\" && c[1] ? i += "\\" + String(Number(c[1]) + o) : (i += c[0], c[0] === "(" && t++);
    }
    return i;
  }).map((r) => `(${r})`).join(e);
}
var rs = /\b\B/;
var vr = "[a-zA-Z]\\w*";
var Wn = "[a-zA-Z_]\\w*";
var kr = "\\b\\d+(\\.\\d+)?";
var xr = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
var yr = "\\b(0b[01]+)";
var os = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
var ss = (n = {}) => {
  const e = /^#![ ]*\//;
  return n.binary && (n.begin = De(
    e,
    /.*\b/,
    n.binary,
    /\b.*/
  )), ke({
    scope: "meta",
    begin: e,
    end: /$/,
    relevance: 0,
    /** @type {ModeCallback} */
    "on:begin": (t, r) => {
      t.index !== 0 && r.ignoreMatch();
    }
  }, n);
};
var He = {
  begin: "\\\\[\\s\\S]",
  relevance: 0
};
var cs = {
  scope: "string",
  begin: "'",
  end: "'",
  illegal: "\\n",
  contains: [He]
};
var is = {
  scope: "string",
  begin: '"',
  end: '"',
  illegal: "\\n",
  contains: [He]
};
var as = {
  begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
};
var ln = function(n, e, t = {}) {
  const r = ke(
    {
      scope: "comment",
      begin: n,
      end: e,
      contains: []
    },
    t
  );
  r.contains.push({
    scope: "doctag",
    // hack to avoid the space from being included. the space is necessary to
    // match here to prevent the plain text rule below from gobbling up doctags
    begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
    end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
    excludeBegin: true,
    relevance: 0
  });
  const o = Zn(
    // list of common 1 and 2 letter words in English
    "I",
    "a",
    "is",
    "so",
    "us",
    "to",
    "at",
    "if",
    "in",
    "it",
    "on",
    // note: this is not an exhaustive list of contractions, just popular ones
    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
    // contractions - can't we'd they're let's, etc
    /[A-Za-z]+[-][a-z]+/,
    // `no-way`, etc.
    /[A-Za-z][a-z]{2,}/
    // allow capitalized words at beginning of sentences
  );
  return r.contains.push(
    {
      // TODO: how to include ", (, ) without breaking grammars that use these for
      // comment delimiters?
      // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
      // ---
      // this tries to find sequences of 3 english words in a row (without any
      // "programming" type syntax) this gives us a strong signal that we've
      // TRULY found a comment - vs perhaps scanning with the wrong language.
      // It's possible to find something that LOOKS like the start of the
      // comment - but then if there is no readable text - good chance it is a
      // false match and not a comment.
      //
      // for a visual example please see:
      // https://github.com/highlightjs/highlight.js/issues/2827
      begin: De(
        /[ ]+/,
        // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
        "(",
        o,
        /[.]?[:]?([.][ ]|[ ])/,
        "){3}"
      )
      // look for 3 words in a row
    }
  ), r;
};
var ls = ln("//", "$");
var us = ln("/\\*", "\\*/");
var fs = ln("#", "$");
var ps = {
  scope: "number",
  begin: kr,
  relevance: 0
};
var hs = {
  scope: "number",
  begin: xr,
  relevance: 0
};
var ds = {
  scope: "number",
  begin: yr,
  relevance: 0
};
var gs = {
  scope: "regexp",
  begin: /\/(?=[^/\n]*\/)/,
  end: /\/[gimuy]*/,
  contains: [
    He,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [He]
    }
  ]
};
var ms = {
  scope: "title",
  begin: vr,
  relevance: 0
};
var _s = {
  scope: "title",
  begin: Wn,
  relevance: 0
};
var bs = {
  // excludes method names from keyword processing
  begin: "\\.\\s*" + Wn,
  relevance: 0
};
var vs = function(n) {
  return Object.assign(
    n,
    {
      /** @type {ModeCallback} */
      "on:begin": (e, t) => {
        t.data._beginMatch = e[1];
      },
      /** @type {ModeCallback} */
      "on:end": (e, t) => {
        t.data._beginMatch !== e[1] && t.ignoreMatch();
      }
    }
  );
};
var Xe = Object.freeze({
  __proto__: null,
  APOS_STRING_MODE: cs,
  BACKSLASH_ESCAPE: He,
  BINARY_NUMBER_MODE: ds,
  BINARY_NUMBER_RE: yr,
  COMMENT: ln,
  C_BLOCK_COMMENT_MODE: us,
  C_LINE_COMMENT_MODE: ls,
  C_NUMBER_MODE: hs,
  C_NUMBER_RE: xr,
  END_SAME_AS_BEGIN: vs,
  HASH_COMMENT_MODE: fs,
  IDENT_RE: vr,
  MATCH_NOTHING_RE: rs,
  METHOD_GUARD: bs,
  NUMBER_MODE: ps,
  NUMBER_RE: kr,
  PHRASAL_WORDS_MODE: as,
  QUOTE_STRING_MODE: is,
  REGEXP_MODE: gs,
  RE_STARTERS_RE: os,
  SHEBANG: ss,
  TITLE_MODE: ms,
  UNDERSCORE_IDENT_RE: Wn,
  UNDERSCORE_TITLE_MODE: _s
});
function ks(n, e) {
  n.input[n.index - 1] === "." && e.ignoreMatch();
}
function xs(n, e) {
  n.className !== void 0 && (n.scope = n.className, delete n.className);
}
function ys(n, e) {
  e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = ks, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0));
}
function Es(n, e) {
  Array.isArray(n.illegal) && (n.illegal = Zn(...n.illegal));
}
function ws(n, e) {
  if (n.match) {
    if (n.begin || n.end)
      throw new Error("begin & end are not supported with match");
    n.begin = n.match, delete n.match;
  }
}
function As(n, e) {
  n.relevance === void 0 && (n.relevance = 1);
}
var Cs = (n, e) => {
  if (!n.beforeMatch)
    return;
  if (n.starts)
    throw new Error("beforeMatch cannot be used with starts");
  const t = Object.assign({}, n);
  Object.keys(n).forEach((r) => {
    delete n[r];
  }), n.keywords = t.keywords, n.begin = De(t.beforeMatch, _r(t.begin)), n.starts = {
    relevance: 0,
    contains: [
      Object.assign(t, { endsParent: true })
    ]
  }, n.relevance = 0, delete t.beforeMatch;
};
var Ss = [
  "of",
  "and",
  "for",
  "in",
  "not",
  "or",
  "if",
  "then",
  "parent",
  // common variable name
  "list",
  // common variable name
  "value"
  // common variable name
];
var Ds = "keyword";
function Er(n, e, t = Ds) {
  const r = /* @__PURE__ */ Object.create(null);
  return typeof n == "string" ? o(t, n.split(" ")) : Array.isArray(n) ? o(t, n) : Object.keys(n).forEach(function(s) {
    Object.assign(
      r,
      Er(n[s], e, s)
    );
  }), r;
  function o(s, i) {
    e && (i = i.map((c) => c.toLowerCase())), i.forEach(function(c) {
      const a = c.split("|");
      r[a[0]] = [s, Ts(a[0], a[1])];
    });
  }
}
function Ts(n, e) {
  return e ? Number(e) : Rs(n) ? 0 : 1;
}
function Rs(n) {
  return Ss.includes(n.toLowerCase());
}
var bt = {};
var Ce = (n) => {
  console.error(n);
};
var vt = (n, ...e) => {
  console.log(`WARN: ${n}`, ...e);
};
var Te = (n, e) => {
  bt[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), bt[`${n}/${e}`] = true);
};
var on = new Error();
function wr(n, e, { key: t }) {
  let r = 0;
  const o = n[t], s = {}, i = {};
  for (let c = 1; c <= e.length; c++)
    i[c + r] = o[c], s[c + r] = true, r += br(e[c - 1]);
  n[t] = i, n[t]._emit = s, n[t]._multi = true;
}
function Ls(n) {
  if (Array.isArray(n.begin)) {
    if (n.skip || n.excludeBegin || n.returnBegin)
      throw Ce("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), on;
    if (typeof n.beginScope != "object" || n.beginScope === null)
      throw Ce("beginScope must be object"), on;
    wr(n, n.begin, { key: "beginScope" }), n.begin = Kn(n.begin, { joinWith: "" });
  }
}
function Ns(n) {
  if (Array.isArray(n.end)) {
    if (n.skip || n.excludeEnd || n.returnEnd)
      throw Ce("skip, excludeEnd, returnEnd not compatible with endScope: {}"), on;
    if (typeof n.endScope != "object" || n.endScope === null)
      throw Ce("endScope must be object"), on;
    wr(n, n.end, { key: "endScope" }), n.end = Kn(n.end, { joinWith: "" });
  }
}
function qs(n) {
  n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope);
}
function Ms(n) {
  qs(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), Ls(n), Ns(n);
}
function Is(n) {
  function e(i, c) {
    return new RegExp(
      Ue(i),
      "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (c ? "g" : "")
    );
  }
  class t {
    constructor() {
      this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      a.position = this.position++, this.matchIndexes[this.matchAt] = a, this.regexes.push([a, c]), this.matchAt += br(c) + 1;
    }
    compile() {
      this.regexes.length === 0 && (this.exec = () => null);
      const c = this.regexes.map((a) => a[1]);
      this.matcherRe = e(Kn(c, { joinWith: "|" }), true), this.lastIndex = 0;
    }
    /** @param {string} s */
    exec(c) {
      this.matcherRe.lastIndex = this.lastIndex;
      const a = this.matcherRe.exec(c);
      if (!a)
        return null;
      const l = a.findIndex((p, f) => f > 0 && p !== void 0), u = this.matchIndexes[l];
      return a.splice(0, l), Object.assign(a, u);
    }
  }
  class r {
    constructor() {
      this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
    }
    // @ts-ignore
    getMatcher(c) {
      if (this.multiRegexes[c])
        return this.multiRegexes[c];
      const a = new t();
      return this.rules.slice(c).forEach(([l, u]) => a.addRule(l, u)), a.compile(), this.multiRegexes[c] = a, a;
    }
    resumingScanAtSamePosition() {
      return this.regexIndex !== 0;
    }
    considerAll() {
      this.regexIndex = 0;
    }
    // @ts-ignore
    addRule(c, a) {
      this.rules.push([c, a]), a.type === "begin" && this.count++;
    }
    /** @param {string} s */
    exec(c) {
      const a = this.getMatcher(this.regexIndex);
      a.lastIndex = this.lastIndex;
      let l = a.exec(c);
      if (this.resumingScanAtSamePosition() && !(l && l.index === this.lastIndex)) {
        const u = this.getMatcher(0);
        u.lastIndex = this.lastIndex + 1, l = u.exec(c);
      }
      return l && (this.regexIndex += l.position + 1, this.regexIndex === this.count && this.considerAll()), l;
    }
  }
  function o(i) {
    const c = new r();
    return i.contains.forEach((a) => c.addRule(a.begin, { rule: a, type: "begin" })), i.terminatorEnd && c.addRule(i.terminatorEnd, { type: "end" }), i.illegal && c.addRule(i.illegal, { type: "illegal" }), c;
  }
  function s(i, c) {
    const a = (
      /** @type CompiledMode */
      i
    );
    if (i.isCompiled)
      return a;
    [
      xs,
      // do this early so compiler extensions generally don't have to worry about
      // the distinction between match/begin
      ws,
      Ms,
      Cs
    ].forEach((u) => u(i, c)), n.compilerExtensions.forEach((u) => u(i, c)), i.__beforeBegin = null, [
      ys,
      // do this later so compiler extensions that come earlier have access to the
      // raw array if they wanted to perhaps manipulate it, etc.
      Es,
      // default to 1 relevance if not specified
      As
    ].forEach((u) => u(i, c)), i.isCompiled = true;
    let l = null;
    return typeof i.keywords == "object" && i.keywords.$pattern && (i.keywords = Object.assign({}, i.keywords), l = i.keywords.$pattern, delete i.keywords.$pattern), l = l || /\w+/, i.keywords && (i.keywords = Er(i.keywords, n.case_insensitive)), a.keywordPatternRe = e(l, true), c && (i.begin || (i.begin = /\B|\b/), a.beginRe = e(a.begin), !i.end && !i.endsWithParent && (i.end = /\B|\b/), i.end && (a.endRe = e(a.end)), a.terminatorEnd = Ue(a.end) || "", i.endsWithParent && c.terminatorEnd && (a.terminatorEnd += (i.end ? "|" : "") + c.terminatorEnd)), i.illegal && (a.illegalRe = e(
      /** @type {RegExp | string} */
      i.illegal
    )), i.contains || (i.contains = []), i.contains = [].concat(...i.contains.map(function(u) {
      return Os(u === "self" ? i : u);
    })), i.contains.forEach(function(u) {
      s(
        /** @type Mode */
        u,
        a
      );
    }), i.starts && s(i.starts, c), a.matcher = o(a), a;
  }
  if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self"))
    throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
  return n.classNameAliases = ke(n.classNameAliases || {}), s(
    /** @type Mode */
    n
  );
}
function Ar(n) {
  return n ? n.endsWithParent || Ar(n.starts) : false;
}
function Os(n) {
  return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function(e) {
    return ke(n, { variants: null }, e);
  })), n.cachedVariants ? n.cachedVariants : Ar(n) ? ke(n, { starts: n.starts ? ke(n.starts) : null }) : Object.isFrozen(n) ? ke(n) : n;
}
var Fs = "11.9.0";
var Bs = class extends Error {
  constructor(e, t) {
    super(e), this.name = "HTMLInjectionError", this.html = t;
  }
};
var An = mr;
var kt = ke;
var xt = Symbol("nomatch");
var Ps = 7;
var Cr = function(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null), r = [];
  let o = true;
  const s = "Could not find the language '{}', did you forget to load/include a language module?", i = { disableAutodetect: true, name: "Plain text", contains: [] };
  let c = {
    ignoreUnescapedHTML: false,
    throwUnescapedHTML: false,
    noHighlightRe: /^(no-?highlight)$/i,
    languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
    classPrefix: "hljs-",
    cssSelector: "pre code",
    languages: null,
    // beta configuration options, subject to change, welcome to discuss
    // https://github.com/highlightjs/highlight.js/issues/1086
    __emitter: Jo
  };
  function a(m) {
    return c.noHighlightRe.test(m);
  }
  function l(m) {
    let k = m.className + " ";
    k += m.parentNode ? m.parentNode.className : "";
    const R = c.languageDetectRe.exec(k);
    if (R) {
      const F = j(R[1]);
      return F || (vt(s.replace("{}", R[1])), vt("Falling back to no-highlight mode for this block.", m)), F ? R[1] : "no-highlight";
    }
    return k.split(/\s+/).find((F) => a(F) || j(F));
  }
  function u(m, k, R) {
    let F = "", U = "";
    typeof k == "object" ? (F = m, R = k.ignoreIllegals, U = k.language) : (Te("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Te("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), U = m, F = k), R === void 0 && (R = true);
    const W = {
      code: F,
      language: U
    };
    T("before:highlight", W);
    const ne = W.result ? W.result : p(W.language, W.code, R);
    return ne.code = W.code, T("after:highlight", ne), ne;
  }
  function p(m, k, R, F) {
    const U = /* @__PURE__ */ Object.create(null);
    function W(y, C) {
      return y.keywords[C];
    }
    function ne() {
      if (!N.keywords) {
        J.addText(V);
        return;
      }
      let y = 0;
      N.keywordPatternRe.lastIndex = 0;
      let C = N.keywordPatternRe.exec(V), I = "";
      for (; C; ) {
        I += V.substring(y, C.index);
        const H = fe.case_insensitive ? C[0].toLowerCase() : C[0], Q = W(N, H);
        if (Q) {
          const [_e, go] = Q;
          if (J.addText(I), I = "", U[H] = (U[H] || 0) + 1, U[H] <= Ps && (Ye += go), _e.startsWith("_"))
            I += C[0];
          else {
            const mo = fe.classNameAliases[_e] || _e;
            ue(C[0], mo);
          }
        } else
          I += C[0];
        y = N.keywordPatternRe.lastIndex, C = N.keywordPatternRe.exec(V);
      }
      I += V.substring(y), J.addText(I);
    }
    function Ke() {
      if (V === "")
        return;
      let y = null;
      if (typeof N.subLanguage == "string") {
        if (!e[N.subLanguage]) {
          J.addText(V);
          return;
        }
        y = p(N.subLanguage, V, true, ft[N.subLanguage]), ft[N.subLanguage] = /** @type {CompiledMode} */
        y._top;
      } else
        y = h5(V, N.subLanguage.length ? N.subLanguage : null);
      N.relevance > 0 && (Ye += y.relevance), J.__addSublanguage(y._emitter, y.language);
    }
    function oe() {
      N.subLanguage != null ? Ke() : ne(), V = "";
    }
    function ue(y, C) {
      y !== "" && (J.startScope(C), J.addText(y), J.endScope());
    }
    function it(y, C) {
      let I = 1;
      const H = C.length - 1;
      for (; I <= H; ) {
        if (!y._emit[I]) {
          I++;
          continue;
        }
        const Q = fe.classNameAliases[y[I]] || y[I], _e = C[I];
        Q ? ue(_e, Q) : (V = _e, ne(), V = ""), I++;
      }
    }
    function at(y, C) {
      return y.scope && typeof y.scope == "string" && J.openNode(fe.classNameAliases[y.scope] || y.scope), y.beginScope && (y.beginScope._wrap ? (ue(V, fe.classNameAliases[y.beginScope._wrap] || y.beginScope._wrap), V = "") : y.beginScope._multi && (it(y.beginScope, C), V = "")), N = Object.create(y, { parent: { value: N } }), N;
    }
    function lt(y, C, I) {
      let H = ns(y.endRe, I);
      if (H) {
        if (y["on:end"]) {
          const Q = new gt(y);
          y["on:end"](C, Q), Q.isMatchIgnored && (H = false);
        }
        if (H) {
          for (; y.endsParent && y.parent; )
            y = y.parent;
          return y;
        }
      }
      if (y.endsWithParent)
        return lt(y.parent, C, I);
    }
    function lo(y) {
      return N.matcher.regexIndex === 0 ? (V += y[0], 1) : (En = true, 0);
    }
    function uo(y) {
      const C = y[0], I = y.rule, H = new gt(I), Q = [I.__beforeBegin, I["on:begin"]];
      for (const _e of Q)
        if (_e && (_e(y, H), H.isMatchIgnored))
          return lo(C);
      return I.skip ? V += C : (I.excludeBegin && (V += C), oe(), !I.returnBegin && !I.excludeBegin && (V = C)), at(I, y), I.returnBegin ? 0 : C.length;
    }
    function fo(y) {
      const C = y[0], I = k.substring(y.index), H = lt(N, y, I);
      if (!H)
        return xt;
      const Q = N;
      N.endScope && N.endScope._wrap ? (oe(), ue(C, N.endScope._wrap)) : N.endScope && N.endScope._multi ? (oe(), it(N.endScope, y)) : Q.skip ? V += C : (Q.returnEnd || Q.excludeEnd || (V += C), oe(), Q.excludeEnd && (V = C));
      do
        N.scope && J.closeNode(), !N.skip && !N.subLanguage && (Ye += N.relevance), N = N.parent;
      while (N !== H.parent);
      return H.starts && at(H.starts, y), Q.returnEnd ? 0 : C.length;
    }
    function po() {
      const y = [];
      for (let C = N; C !== fe; C = C.parent)
        C.scope && y.unshift(C.scope);
      y.forEach((C) => J.openNode(C));
    }
    let We = {};
    function ut(y, C) {
      const I = C && C[0];
      if (V += y, I == null)
        return oe(), 0;
      if (We.type === "begin" && C.type === "end" && We.index === C.index && I === "") {
        if (V += k.slice(C.index, C.index + 1), !o) {
          const H = new Error(`0 width match regex (${m})`);
          throw H.languageName = m, H.badRule = We.rule, H;
        }
        return 1;
      }
      if (We = C, C.type === "begin")
        return uo(C);
      if (C.type === "illegal" && !R) {
        const H = new Error('Illegal lexeme "' + I + '" for mode "' + (N.scope || "<unnamed>") + '"');
        throw H.mode = N, H;
      } else if (C.type === "end") {
        const H = fo(C);
        if (H !== xt)
          return H;
      }
      if (C.type === "illegal" && I === "")
        return 1;
      if (yn > 1e5 && yn > C.index * 3)
        throw new Error("potential infinite loop, way more iterations than matches");
      return V += I, I.length;
    }
    const fe = j(m);
    if (!fe)
      throw Ce(s.replace("{}", m)), new Error('Unknown language: "' + m + '"');
    const ho = Is(fe);
    let xn = "", N = F || ho;
    const ft = {}, J = new c.__emitter(c);
    po();
    let V = "", Ye = 0, ye = 0, yn = 0, En = false;
    try {
      if (fe.__emitTokens)
        fe.__emitTokens(k, J);
      else {
        for (N.matcher.considerAll(); ; ) {
          yn++, En ? En = false : N.matcher.considerAll(), N.matcher.lastIndex = ye;
          const y = N.matcher.exec(k);
          if (!y)
            break;
          const C = k.substring(ye, y.index), I = ut(C, y);
          ye = y.index + I;
        }
        ut(k.substring(ye));
      }
      return J.finalize(), xn = J.toHTML(), {
        language: m,
        value: xn,
        relevance: Ye,
        illegal: false,
        _emitter: J,
        _top: N
      };
    } catch (y) {
      if (y.message && y.message.includes("Illegal"))
        return {
          language: m,
          value: An(k),
          illegal: true,
          relevance: 0,
          _illegalBy: {
            message: y.message,
            index: ye,
            context: k.slice(ye - 100, ye + 100),
            mode: y.mode,
            resultSoFar: xn
          },
          _emitter: J
        };
      if (o)
        return {
          language: m,
          value: An(k),
          illegal: false,
          relevance: 0,
          errorRaised: y,
          _emitter: J,
          _top: N
        };
      throw y;
    }
  }
  function f(m) {
    const k = {
      value: An(m),
      illegal: false,
      relevance: 0,
      _top: i,
      _emitter: new c.__emitter(c)
    };
    return k._emitter.addText(m), k;
  }
  function h5(m, k) {
    k = k || c.languages || Object.keys(e);
    const R = f(m), F = k.filter(j).filter(K).map(
      (oe) => p(oe, m, false)
    );
    F.unshift(R);
    const U = F.sort((oe, ue) => {
      if (oe.relevance !== ue.relevance)
        return ue.relevance - oe.relevance;
      if (oe.language && ue.language) {
        if (j(oe.language).supersetOf === ue.language)
          return 1;
        if (j(ue.language).supersetOf === oe.language)
          return -1;
      }
      return 0;
    }), [W, ne] = U, Ke = W;
    return Ke.secondBest = ne, Ke;
  }
  function d(m, k, R) {
    const F = k && t[k] || R;
    m.classList.add("hljs"), m.classList.add(`language-${F}`);
  }
  function g(m) {
    let k = null;
    const R = l(m);
    if (a(R))
      return;
    if (T(
      "before:highlightElement",
      { el: m, language: R }
    ), m.dataset.highlighted) {
      console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", m);
      return;
    }
    if (m.children.length > 0 && (c.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(m)), c.throwUnescapedHTML))
      throw new Bs(
        "One of your code blocks includes unescaped HTML.",
        m.innerHTML
      );
    k = m;
    const F = k.textContent, U = R ? u(F, { language: R, ignoreIllegals: true }) : h5(F);
    m.innerHTML = U.value, m.dataset.highlighted = "yes", d(m, R, U.language), m.result = {
      language: U.language,
      // TODO: remove with version 11.0
      re: U.relevance,
      relevance: U.relevance
    }, U.secondBest && (m.secondBest = {
      language: U.secondBest.language,
      relevance: U.secondBest.relevance
    }), T("after:highlightElement", { el: m, result: U, text: F });
  }
  function E(m) {
    c = kt(c, m);
  }
  const x = () => {
    D(), Te("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
  };
  function b() {
    D(), Te("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
  }
  let A = false;
  function D() {
    if (document.readyState === "loading") {
      A = true;
      return;
    }
    document.querySelectorAll(c.cssSelector).forEach(g);
  }
  function L() {
    A && D();
  }
  typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", L, false);
  function v(m, k) {
    let R = null;
    try {
      R = k(n);
    } catch (F) {
      if (Ce("Language definition for '{}' could not be registered.".replace("{}", m)), o)
        Ce(F);
      else
        throw F;
      R = i;
    }
    R.name || (R.name = m), e[m] = R, R.rawDefinition = k.bind(null, n), R.aliases && M(R.aliases, { languageName: m });
  }
  function O(m) {
    delete e[m];
    for (const k of Object.keys(t))
      t[k] === m && delete t[k];
  }
  function z() {
    return Object.keys(e);
  }
  function j(m) {
    return m = (m || "").toLowerCase(), e[m] || e[t[m]];
  }
  function M(m, { languageName: k }) {
    typeof m == "string" && (m = [m]), m.forEach((R) => {
      t[R.toLowerCase()] = k;
    });
  }
  function K(m) {
    const k = j(m);
    return k && !k.disableAutodetect;
  }
  function q(m) {
    m["before:highlightBlock"] && !m["before:highlightElement"] && (m["before:highlightElement"] = (k) => {
      m["before:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    }), m["after:highlightBlock"] && !m["after:highlightElement"] && (m["after:highlightElement"] = (k) => {
      m["after:highlightBlock"](
        Object.assign({ block: k.el }, k)
      );
    });
  }
  function Z(m) {
    q(m), r.push(m);
  }
  function _(m) {
    const k = r.indexOf(m);
    k !== -1 && r.splice(k, 1);
  }
  function T(m, k) {
    const R = m;
    r.forEach(function(F) {
      F[R] && F[R](k);
    });
  }
  function w(m) {
    return Te("10.7.0", "highlightBlock will be removed entirely in v12.0"), Te("10.7.0", "Please use highlightElement now."), g(m);
  }
  Object.assign(n, {
    highlight: u,
    highlightAuto: h5,
    highlightAll: D,
    highlightElement: g,
    // TODO: Remove with v12 API
    highlightBlock: w,
    configure: E,
    initHighlighting: x,
    initHighlightingOnLoad: b,
    registerLanguage: v,
    unregisterLanguage: O,
    listLanguages: z,
    getLanguage: j,
    registerAliases: M,
    autoDetection: K,
    inherit: kt,
    addPlugin: Z,
    removePlugin: _
  }), n.debugMode = function() {
    o = false;
  }, n.safeMode = function() {
    o = true;
  }, n.versionString = Fs, n.regex = {
    concat: De,
    lookahead: _r,
    either: Zn,
    optional: Qo,
    anyNumberOfTimes: Xo
  };
  for (const m in Xe)
    typeof Xe[m] == "object" && gr(Xe[m]);
  return Object.assign(n, Xe), n;
};
var Ne = Cr({});
Ne.newInstance = () => Cr({});
var $s = Ne;
Ne.HighlightJS = Ne;
Ne.default = Ne;
var be = Gn($s);
var yt = "[A-Za-z$_][0-9A-Za-z$_]*";
var zs = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var Us = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
var Sr = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var Dr = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
var Tr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
var Hs = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var Vs = [].concat(
  Tr,
  Sr,
  Dr
);
function Rr(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = yt, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: yt,
    keyword: zs,
    literal: Us,
    built_in: Vs,
    "variable.language": Hs
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h5 = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h5,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Sr,
        ...Dr
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Tr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h5,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function Lr(n) {
  const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, s = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, i = n.inherit(s, {
    begin: /\(/,
    end: /\)/
  }), c = n.inherit(n.APOS_STRING_MODE, { className: "string" }), a = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), l = {
    endsWithParent: true,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: true,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [o]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [o]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: true,
    unicodeRegex: true,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          s,
          a,
          c,
          i,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  s,
                  i,
                  a,
                  c
                ]
              }
            ]
          }
        ]
      },
      n.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      o,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              a
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [l],
        starts: {
          end: /<\/style>/,
          returnEnd: true,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [l],
        starts: {
          end: /<\/script>/,
          returnEnd: true,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            t,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0,
            starts: l
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            t,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: t,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: true
          }
        ]
      }
    ]
  };
}
var un = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [r, o] of e)
    t[r] = o;
  return t;
};
var Gs = {};
var js = { class: "chat-button" };
function Zs(n, e) {
  return openBlock(), createElementBlock("button", js, [
    renderSlot(n.$slots, "default")
  ]);
}
var Ks = un(Gs, [["render", Zs]]);
var Ws = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Ys = createBaseVNode("path", {
  fill: "currentColor",
  d: "M19 6.41L17.59 5L12 10.59L6.41 5L5 6.41L10.59 12L5 17.59L6.41 19L12 13.41L17.59 19L19 17.59L13.41 12z"
}, null, -1);
var Js = [
  Ys
];
function Xs(n, e) {
  return openBlock(), createElementBlock("svg", Ws, [...Js]);
}
var Qs = { name: "mdi-close", render: Xs };
function Yn() {
  return inject(fr);
}
function Ge() {
  return {
    options: inject(pr)
  };
}
function fn() {
  const { options: n } = Ge(), e = (n == null ? void 0 : n.defaultLanguage) ?? "en";
  function t(o) {
    var i, c;
    const s = (c = (i = n == null ? void 0 : n.i18n) == null ? void 0 : i[e]) == null ? void 0 : c[o];
    return isRef(s) ? s.value : s ?? o;
  }
  function r(o) {
    var s, i;
    return !!((i = (s = n == null ? void 0 : n.i18n) == null ? void 0 : s[e]) != null && i[o]);
  }
  return { t, te: r };
}
var ec = { class: "chat-get-started" };
var nc = defineComponent({
  __name: "GetStarted",
  setup(n) {
    const { t: e } = fn();
    return (t, r) => (openBlock(), createElementBlock("div", ec, [
      createVNode(Ks, {
        onClick: r[0] || (r[0] = (o) => t.$emit("click:button"))
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(unref(e)("getStarted")), 1)
        ]),
        _: 1
      })
    ]));
  }
});
var tc = {};
var rc = { class: "chat-powered-by" };
var oc = createBaseVNode("a", { href: "https://n8n.io?utm_source=n8n-external&utm_medium=widget-powered-by" }, "n8n", -1);
function sc(n, e) {
  return openBlock(), createElementBlock("div", rc, [
    createTextVNode(" Powered by "),
    oc
  ]);
}
var cc = un(tc, [["render", sc]]);
var ic = { class: "chat-get-started-footer" };
var ac = { key: 0 };
var lc = defineComponent({
  __name: "GetStartedFooter",
  setup(n) {
    const { t: e, te: t } = fn();
    return (r, o) => (openBlock(), createElementBlock("div", ic, [
      unref(t)("footer") ? (openBlock(), createElementBlock("div", ac, toDisplayString(unref(e)("footer")), 1)) : createCommentVNode("", true),
      createVNode(cc)
    ]));
  }
});
function uc(n) {
  return getCurrentScope() ? (onScopeDispose(n), true) : false;
}
function fc() {
  const n = /* @__PURE__ */ new Set(), e = (o) => {
    n.delete(o);
  };
  return {
    on: (o) => {
      n.add(o);
      const s = () => e(o);
      return uc(s), {
        off: s
      };
    },
    off: e,
    trigger: (...o) => Promise.all(Array.from(n).map((s) => s(...o)))
  };
}
var pc = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var hc = (n, e) => Object.prototype.hasOwnProperty.call(n, e);
var dc = pc ? window.document : void 0;
var gc = {
  multiple: true,
  accept: "*",
  reset: false,
  directory: false
};
function mc(n = {}) {
  const {
    document: e = dc
  } = n, t = ref(null), { on: r, trigger: o } = fc();
  let s;
  e && (s = e.createElement("input"), s.type = "file", s.onchange = (a) => {
    const l = a.target;
    t.value = l.files, o(t.value);
  });
  const i = () => {
    t.value = null, s && s.value && (s.value = "", o(null));
  }, c = (a) => {
    if (!s)
      return;
    const l = {
      ...gc,
      ...n,
      ...a
    };
    s.multiple = l.multiple, s.accept = l.accept, s.webkitdirectory = l.directory, hc(l, "capture") && (s.capture = l.capture), l.reset && i(), s.click();
  };
  return {
    files: readonly(t),
    open: c,
    reset: i,
    onChange: r
  };
}
var _c = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var bc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 2H6c-1.11 0-2 .89-2 2v16c0 1.11.89 2 2 2h7.81c-.53-.91-.81-1.95-.81-3c0-3.31 2.69-6 6-6c.34 0 .67.03 1 .08V8zm-1 7V3.5L18.5 9zm10 11h-3v3h-2v-3h-3v-2h3v-3h2v3h3z"
}, null, -1);
var vc = [
  bc
];
function kc(n, e) {
  return openBlock(), createElementBlock("svg", _c, [...vc]);
}
var xc = { name: "mdi-filePlus", render: kc };
var yc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Ec = createBaseVNode("path", {
  fill: "currentColor",
  d: "m2 21l21-9L2 3v7l15 2l-15 2z"
}, null, -1);
var wc = [
  Ec
];
function Ac(n, e) {
  return openBlock(), createElementBlock("svg", yc, [...wc]);
}
var Cc = { name: "mdi-send", render: Ac };
var Sc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Dc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M20 6.91L17.09 4L12 9.09L6.91 4L4 6.91L9.09 12L4 17.09L6.91 20L12 14.91L17.09 20L20 17.09L14.91 12z"
}, null, -1);
var Tc = [
  Dc
];
function Rc(n, e) {
  return openBlock(), createElementBlock("svg", Sc, [...Tc]);
}
var Lc = { name: "mdi-closeThick", render: Rc };
var Nc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var qc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m0 18h12v-8l-4 4l-2-2zM8 9a2 2 0 0 0-2 2a2 2 0 0 0 2 2a2 2 0 0 0 2-2a2 2 0 0 0-2-2"
}, null, -1);
var Mc = [
  qc
];
function Ic(n, e) {
  return openBlock(), createElementBlock("svg", Nc, [...Mc]);
}
var Oc = { name: "mdi-fileImage", render: Ic };
var Fc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Bc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8zm-1 11h-2v5a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2c.4 0 .7.1 1 .3V11h3zm0-4V3.5L18.5 9z"
}, null, -1);
var Pc = [
  Bc
];
function $c(n, e) {
  return openBlock(), createElementBlock("svg", Fc, [...Pc]);
}
var zc = { name: "mdi-fileMusic", render: $c };
var Uc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Hc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m9 16v-2H6v2zm3-4v-2H6v2z"
}, null, -1);
var Vc = [
  Hc
];
function Gc(n, e) {
  return openBlock(), createElementBlock("svg", Uc, [...Vc]);
}
var Et = { name: "mdi-fileText", render: Gc };
var jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Zc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M13 9h5.5L13 3.5zM6 2h8l6 6v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4c0-1.11.89-2 2-2m11 17v-6l-3 2.2V13H7v6h7v-2.2z"
}, null, -1);
var Kc = [
  Zc
];
function Wc(n, e) {
  return openBlock(), createElementBlock("svg", jc, [...Kc]);
}
var Yc = { name: "mdi-fileVideo", render: Wc };
var Jc = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Xc = createBaseVNode("path", {
  fill: "currentColor",
  d: "M14 3v2h3.59l-9.83 9.83l1.41 1.41L19 6.41V10h2V3m-2 16H5V5h7V3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7h-2z"
}, null, -1);
var Qc = [
  Xc
];
function ei(n, e) {
  return openBlock(), createElementBlock("svg", Jc, [...Qc]);
}
var ni = { name: "mdi-openInNew", render: ei };
var ti = { class: "chat-file-name" };
var ri = defineComponent({
  __name: "ChatFile",
  props: {
    file: {},
    isRemovable: { type: Boolean },
    isPreviewable: { type: Boolean }
  },
  emits: ["remove"],
  setup(n, { emit: e }) {
    const t = n, r = e, o = {
      document: Et,
      audio: zc,
      image: Oc,
      video: Yc
    }, s = computed(() => {
      var a;
      const c = (a = t.file) == null ? void 0 : a.type.split("/")[0];
      return o[c] || Et;
    });
    function i() {
      t.isRemovable && r("remove", t.file), t.isPreviewable && window.open(URL.createObjectURL(t.file));
    }
    return (c, a) => (openBlock(), createElementBlock("div", {
      class: "chat-file",
      onClick: i
    }, [
      createVNode(unref(s)),
      createBaseVNode("p", ti, toDisplayString(c.file.name), 1),
      c.isRemovable ? (openBlock(), createBlock(unref(Lc), {
        key: 0,
        class: "chat-file-delete"
      })) : createCommentVNode("", true),
      c.isPreviewable ? (openBlock(), createBlock(unref(ni), {
        key: 1,
        class: "chat-file-preview"
      })) : createCommentVNode("", true)
    ]));
  }
});
var Nr = un(ri, [["__scopeId", "data-v-c15a8ecf"]]);
var oi = { class: "chat-inputs" };
var si = ["disabled", "placeholder"];
var ci = { class: "chat-inputs-controls" };
var ii = ["disabled"];
var ai = ["disabled"];
var li = {
  key: 0,
  class: "chat-files"
};
var ui = defineComponent({
  __name: "Input",
  emits: ["arrowKeyDown"],
  setup(n, { emit: e }) {
    const t = e, { options: r } = Ge(), o = Yn(), { waitingForResponse: s } = o, { t: i } = fn(), c = ref(null), a = ref(null), l = ref(""), u = ref(false), p = computed(() => {
      var q;
      return l.value === "" || s.value || ((q = r.disabled) == null ? void 0 : q.value) === true;
    }), f = computed(() => {
      var q;
      return ((q = r.disabled) == null ? void 0 : q.value) === true;
    }), h5 = computed(
      () => {
        var q;
        return d.value && s.value && !((q = r.disabled) != null && q.value);
      }
    ), d = computed(() => unref(r.allowFileUploads) === true), g = computed(() => unref(r.allowedFilesMimeTypes)), E = computed(() => ({
      "--controls-count": d.value ? 2 : 1
    })), {
      open: x,
      reset: b,
      onChange: A
    } = mc({
      multiple: true,
      reset: false
    });
    A((q) => {
      if (!q)
        return;
      const Z = new DataTransfer();
      if (c.value)
        for (let _ = 0; _ < c.value.length; _++)
          Z.items.add(c.value[_]);
      for (let _ = 0; _ < q.length; _++)
        Z.items.add(q[_]);
      c.value = Z.files;
    }), onMounted(() => {
      re.on("focusInput", L), re.on("blurInput", D), re.on("setInputValue", v);
    }), onUnmounted(() => {
      re.off("focusInput", L), re.off("blurInput", D), re.off("setInputValue", v);
    });
    function D() {
      a.value && a.value.blur();
    }
    function L() {
      a.value && a.value.focus();
    }
    function v(q) {
      l.value = q, L();
    }
    async function O(q) {
      if (q.preventDefault(), p.value)
        return;
      const Z = l.value;
      l.value = "", u.value = true, await o.sendMessage(Z, Array.from(c.value ?? [])), u.value = false, b(), c.value = null;
    }
    async function z(q) {
      q.shiftKey || await O(q);
    }
    function j(q) {
      if (!c.value)
        return;
      const Z = new DataTransfer();
      for (let _ = 0; _ < c.value.length; _++) {
        const T = c.value[_];
        q.name !== T.name && Z.items.add(T);
      }
      b(), c.value = Z.files;
    }
    function M(q) {
      (q.key === "ArrowUp" || q.key === "ArrowDown") && (q.preventDefault(), t("arrowKeyDown", {
        key: q.key,
        currentInputValue: l.value
      }));
    }
    function K() {
      h5.value || x({ accept: unref(g) });
    }
    return (q, Z) => {
      var _;
      return openBlock(), createElementBlock("div", {
        class: "chat-input",
        style: normalizeStyle(E.value),
        onKeydown: withModifiers(M, ["stop"])
      }, [
        createBaseVNode("div", oi, [
          withDirectives(createBaseVNode("textarea", {
            ref_key: "chatTextArea",
            ref: a,
            "onUpdate:modelValue": Z[0] || (Z[0] = (T) => l.value = T),
            disabled: f.value,
            placeholder: unref(i)("inputPlaceholder"),
            onKeydown: withKeys(z, ["enter"])
          }, null, 40, si), [
            [vModelText, l.value]
          ]),
          createBaseVNode("div", ci, [
            d.value ? (openBlock(), createElementBlock("button", {
              key: 0,
              disabled: h5.value,
              class: "chat-input-send-button",
              onClick: K
            }, [
              createVNode(unref(xc), {
                height: "24",
                width: "24"
              })
            ], 8, ii)) : createCommentVNode("", true),
            createBaseVNode("button", {
              disabled: p.value,
              class: "chat-input-send-button",
              onClick: O
            }, [
              createVNode(unref(Cc), {
                height: "24",
                width: "24"
              })
            ], 8, ai)
          ])
        ]),
        (_ = c.value) != null && _.length && !u.value ? (openBlock(), createElementBlock("div", li, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (T) => (openBlock(), createBlock(Nr, {
            key: T.name,
            file: T,
            "is-removable": true,
            onRemove: j
          }, null, 8, ["file"]))), 128))
        ])) : createCommentVNode("", true)
      ], 36);
    };
  }
});
var fi = un(ui, [["__scopeId", "data-v-2a7fb1c3"]]);
var pi = { class: "chat-layout" };
var hi = {
  key: 0,
  class: "chat-header"
};
var di = {
  key: 2,
  class: "chat-footer"
};
var gi = defineComponent({
  __name: "Layout",
  setup(n) {
    const e = ref(null);
    function t() {
      const r = e.value;
      r && (r.scrollTop = r.scrollHeight);
    }
    return onMounted(() => {
      re.on("scrollToBottom", t), window.addEventListener("resize", t);
    }), onBeforeUnmount(() => {
      re.off("scrollToBottom", t), window.removeEventListener("resize", t);
    }), (r, o) => (openBlock(), createElementBlock("main", pi, [
      r.$slots.header ? (openBlock(), createElementBlock("div", hi, [
        renderSlot(r.$slots, "header")
      ])) : createCommentVNode("", true),
      r.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 1,
        ref_key: "chatBodyRef",
        ref: e,
        class: "chat-body"
      }, [
        renderSlot(r.$slots, "default")
      ], 512)) : createCommentVNode("", true),
      r.$slots.footer ? (openBlock(), createElementBlock("div", di, [
        renderSlot(r.$slots, "footer")
      ])) : createCommentVNode("", true)
    ]));
  }
});
function mi(n) {
  const e = n.regex, t = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [t]
      }
      // default values
    ]
  };
  Object.assign(t, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const o = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [n.BACKSLASH_ESCAPE]
  }, s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      n.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, i = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      n.BACKSLASH_ESCAPE,
      t,
      o
    ]
  };
  o.contains.push(i);
  const c = {
    match: /\\"/
  }, a = {
    className: "string",
    begin: /'/,
    end: /'/
  }, l = {
    match: /\\'/
  }, u = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      n.NUMBER_MODE,
      t
    ]
  }, p = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], f = n.SHEBANG({
    binary: `(${p.join("|")})`,
    relevance: 10
  }), h5 = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: true,
    contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, d = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], E = { match: /(\/[a-z._-]+)+/ }, x = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], b = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], A = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], D = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: ["sh"],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: d,
      literal: g,
      built_in: [
        ...x,
        ...b,
        // Shell modifiers
        "set",
        "shopt",
        ...A,
        ...D
      ]
    },
    contains: [
      f,
      // to catch known shells and boost relevancy
      n.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      h5,
      u,
      n.HASH_COMMENT_MODE,
      s,
      E,
      i,
      c,
      a,
      l,
      t
    ]
  };
}
function _i(n) {
  const e = n.regex, t = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], c = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, a = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, l = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: c,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, p = {
    className: "string",
    contains: [n.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          n.BACKSLASH_ESCAPE,
          a,
          u,
          l
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          n.BACKSLASH_ESCAPE,
          u,
          l
        ]
      },
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h5 = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, d = `\\b|${r.join("|")}`, g = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h5}))[eE][+-]?(${f})[jJ]?(?=${d})`
      },
      {
        begin: `(${h5})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${d})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${d})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${d})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${d})`
      }
    ]
  }, E = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: c,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: true
      }
    ]
  }, x = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: true
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: true,
        excludeEnd: true,
        keywords: c,
        contains: [
          "self",
          a,
          g,
          p,
          n.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return l.contains = [
    p,
    g,
    a
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: true,
    keywords: c,
    illegal: /(<\/|\?)|=>/,
    contains: [
      a,
      g,
      {
        // very common convention
        begin: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      p,
      E,
      n.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          t
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [x]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              t,
              /\s*/,
              /\(\s*/,
              t,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              t
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          g,
          x,
          p
        ]
      }
    ]
  };
}
var sn = "[A-Za-z$_][0-9A-Za-z$_]*";
var qr = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends"
];
var Mr = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
];
var Ir = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
];
var Or = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
];
var Fr = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
];
var Br = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
];
var Pr = [].concat(
  Fr,
  Ir,
  Or
);
function bi(n) {
  const e = n.regex, t = (k, { after: R }) => {
    const F = "</" + k[0].slice(1);
    return k.input.indexOf(F, R) !== -1;
  }, r = sn, o = {
    begin: "<>",
    end: "</>"
  }, s = /<[A-Za-z0-9\\._:-]+\s*\/>/, i = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (k, R) => {
      const F = k[0].length + k.index, U = k.input[F];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        U === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        U === ","
      ) {
        R.ignoreMatch();
        return;
      }
      U === ">" && (t(k, { after: F }) || R.ignoreMatch());
      let W;
      const ne = k.input.substring(F);
      if (W = ne.match(/^\s*=/)) {
        R.ignoreMatch();
        return;
      }
      if ((W = ne.match(/^\s+extends\s+/)) && W.index === 0) {
        R.ignoreMatch();
        return;
      }
    }
  }, c = {
    $pattern: sn,
    keyword: qr,
    literal: Mr,
    built_in: Pr,
    "variable.language": Br
  }, a = "[0-9](_?[0-9])*", l = `\\.(${a})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", p = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${l})|\\.)?|(${l}))[eE][+-]?(${a})\\b` },
      { begin: `\\b(${u})\\b((${l})\\b|\\.)?|(${l})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: c,
    contains: []
    // defined later
  }, h5 = {
    begin: "html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, d = {
    begin: "css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, g = {
    begin: "gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: false,
      contains: [
        n.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, E = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      n.BACKSLASH_ESCAPE,
      f
    ]
  }, b = {
    className: "comment",
    variants: [
      n.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: true,
                  excludeBegin: true,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: true,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      n.C_BLOCK_COMMENT_MODE,
      n.C_LINE_COMMENT_MODE
    ]
  }, A = [
    n.APOS_STRING_MODE,
    n.QUOTE_STRING_MODE,
    h5,
    d,
    g,
    E,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    p
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = A.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: c,
    contains: [
      "self"
    ].concat(A)
  });
  const D = [].concat(b, f.contains), L = D.concat([
    // eat recursive parens in sub expressions
    {
      begin: /\(/,
      end: /\)/,
      keywords: c,
      contains: ["self"].concat(D)
    }
  ]), v = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    excludeBegin: true,
    excludeEnd: true,
    keywords: c,
    contains: L
  }, O = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, z = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ir,
        ...Or
      ]
    }
  }, j = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, M = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [v],
    illegal: /%/
  }, K = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function q(k) {
    return e.concat("(?!", k.join("|"), ")");
  }
  const Z = {
    match: e.concat(
      /\b/,
      q([
        ...Fr,
        "super",
        "import"
      ]),
      r,
      e.lookahead(/\(/)
    ),
    className: "title.function",
    relevance: 0
  }, _ = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: true,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, T = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      v
    ]
  }, w = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", m = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(w)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      v
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: c,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: L, CLASS_REFERENCE: z },
    illegal: /#(?![$_A-z])/,
    contains: [
      n.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      j,
      n.APOS_STRING_MODE,
      n.QUOTE_STRING_MODE,
      h5,
      d,
      g,
      E,
      b,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      p,
      z,
      {
        className: "attr",
        begin: r + e.lookahead(":"),
        relevance: 0
      },
      m,
      {
        // "value" container
        begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          b,
          n.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: w,
            returnBegin: true,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: n.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: true
                  },
                  {
                    begin: /\(/,
                    end: /\)/,
                    excludeBegin: true,
                    excludeEnd: true,
                    keywords: c,
                    contains: L
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: s },
              {
                begin: i.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": i.isTrulyOpeningTag,
                end: i.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: i.begin,
                end: i.end,
                skip: true,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      M,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: true,
        label: "func.def",
        contains: [
          v,
          n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      _,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [v]
      },
      Z,
      K,
      O,
      T,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function vi(n) {
  const e = bi(n), t = sn, r = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], o = {
    beginKeywords: "namespace",
    end: /\{/,
    excludeEnd: true,
    contains: [e.exports.CLASS_REFERENCE]
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: true,
    keywords: {
      keyword: "interface extends",
      built_in: r
    },
    contains: [e.exports.CLASS_REFERENCE]
  }, i = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, c = [
    "type",
    "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override"
  ], a = {
    $pattern: sn,
    keyword: qr.concat(c),
    literal: Mr,
    built_in: Pr.concat(r),
    "variable.language": Br
  }, l = {
    className: "meta",
    begin: "@" + t
  }, u = (f, h5, d) => {
    const g = f.contains.findIndex((E) => E.label === h5);
    if (g === -1)
      throw new Error("can not find mode to replace");
    f.contains.splice(g, 1, d);
  };
  Object.assign(e.keywords, a), e.exports.PARAMS_CONTAINS.push(l), e.contains = e.contains.concat([
    l,
    o,
    s
  ]), u(e, "shebang", n.SHEBANG()), u(e, "use_strict", i);
  const p = e.contains.find((f) => f.label === "func.def");
  return p.relevance = 0, Object.assign(e, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), e;
}
function ki(n, e) {
  var t, r, o = n.attrs[n.attrIndex("href")][1];
  for (t = 0; t < e.length; ++t) {
    if (r = e[t], typeof r.matcher == "function") {
      if (r.matcher(o, r))
        return r;
      continue;
    }
    return r;
  }
}
function xi(n, e, t) {
  Object.keys(t).forEach(function(r) {
    var o, s = t[r];
    r === "className" && (r = "class"), o = e[n].attrIndex(r), o < 0 ? e[n].attrPush([r, s]) : e[n].attrs[o][1] = s;
  });
}
function $r(n, e) {
  e ? e = Array.isArray(e) ? e : [e] : e = [], Object.freeze(e);
  var t = n.renderer.rules.link_open || this.defaultRender;
  n.renderer.rules.link_open = function(r, o, s, i, c) {
    var a = ki(r[o], e), l = a && a.attrs;
    return l && xi(o, r, l), t(r, o, s, i, c);
  };
}
$r.defaultRender = function(n, e, t, r, o) {
  return o.renderToken(n, e, t);
};
var yi = $r;
var Ei = Gn(yi);
var $ = {};
var wi = "Á";
var Ai = "á";
var Ci = "Ă";
var Si = "ă";
var Di = "∾";
var Ti = "∿";
var Ri = "∾̳";
var Li = "Â";
var Ni = "â";
var qi = "´";
var Mi = "А";
var Ii = "а";
var Oi = "Æ";
var Fi = "æ";
var Bi = "⁡";
var Pi = "𝔄";
var $i = "𝔞";
var zi = "À";
var Ui = "à";
var Hi = "ℵ";
var Vi = "ℵ";
var Gi = "Α";
var ji = "α";
var Zi = "Ā";
var Ki = "ā";
var Wi = "⨿";
var Yi = "&";
var Ji = "&";
var Xi = "⩕";
var Qi = "⩓";
var ea = "∧";
var na = "⩜";
var ta = "⩘";
var ra = "⩚";
var oa = "∠";
var sa = "⦤";
var ca = "∠";
var ia = "⦨";
var aa = "⦩";
var la = "⦪";
var ua = "⦫";
var fa = "⦬";
var pa = "⦭";
var ha = "⦮";
var da = "⦯";
var ga = "∡";
var ma = "∟";
var _a = "⊾";
var ba = "⦝";
var va = "∢";
var ka = "Å";
var xa = "⍼";
var ya = "Ą";
var Ea = "ą";
var wa = "𝔸";
var Aa = "𝕒";
var Ca = "⩯";
var Sa = "≈";
var Da = "⩰";
var Ta = "≊";
var Ra = "≋";
var La = "'";
var Na = "⁡";
var qa = "≈";
var Ma = "≊";
var Ia = "Å";
var Oa = "å";
var Fa = "𝒜";
var Ba = "𝒶";
var Pa = "≔";
var $a = "*";
var za = "≈";
var Ua = "≍";
var Ha = "Ã";
var Va = "ã";
var Ga = "Ä";
var ja = "ä";
var Za = "∳";
var Ka = "⨑";
var Wa = "≌";
var Ya = "϶";
var Ja = "‵";
var Xa = "∽";
var Qa = "⋍";
var el = "∖";
var nl = "⫧";
var tl = "⊽";
var rl = "⌅";
var ol = "⌆";
var sl = "⌅";
var cl = "⎵";
var il = "⎶";
var al = "≌";
var ll = "Б";
var ul = "б";
var fl = "„";
var pl = "∵";
var hl = "∵";
var dl = "∵";
var gl = "⦰";
var ml = "϶";
var _l = "ℬ";
var bl = "ℬ";
var vl = "Β";
var kl = "β";
var xl = "ℶ";
var yl = "≬";
var El = "𝔅";
var wl = "𝔟";
var Al = "⋂";
var Cl = "◯";
var Sl = "⋃";
var Dl = "⨀";
var Tl = "⨁";
var Rl = "⨂";
var Ll = "⨆";
var Nl = "★";
var ql = "▽";
var Ml = "△";
var Il = "⨄";
var Ol = "⋁";
var Fl = "⋀";
var Bl = "⤍";
var Pl = "⧫";
var $l = "▪";
var zl = "▴";
var Ul = "▾";
var Hl = "◂";
var Vl = "▸";
var Gl = "␣";
var jl = "▒";
var Zl = "░";
var Kl = "▓";
var Wl = "█";
var Yl = "=⃥";
var Jl = "≡⃥";
var Xl = "⫭";
var Ql = "⌐";
var eu = "𝔹";
var nu = "𝕓";
var tu = "⊥";
var ru = "⊥";
var ou = "⋈";
var su = "⧉";
var cu = "┐";
var iu = "╕";
var au = "╖";
var lu = "╗";
var uu = "┌";
var fu = "╒";
var pu = "╓";
var hu = "╔";
var du = "─";
var gu = "═";
var mu = "┬";
var _u = "╤";
var bu = "╥";
var vu = "╦";
var ku = "┴";
var xu = "╧";
var yu = "╨";
var Eu = "╩";
var wu = "⊟";
var Au = "⊞";
var Cu = "⊠";
var Su = "┘";
var Du = "╛";
var Tu = "╜";
var Ru = "╝";
var Lu = "└";
var Nu = "╘";
var qu = "╙";
var Mu = "╚";
var Iu = "│";
var Ou = "║";
var Fu = "┼";
var Bu = "╪";
var Pu = "╫";
var $u = "╬";
var zu = "┤";
var Uu = "╡";
var Hu = "╢";
var Vu = "╣";
var Gu = "├";
var ju = "╞";
var Zu = "╟";
var Ku = "╠";
var Wu = "‵";
var Yu = "˘";
var Ju = "˘";
var Xu = "¦";
var Qu = "𝒷";
var ef = "ℬ";
var nf = "⁏";
var tf = "∽";
var rf = "⋍";
var of = "⧅";
var sf = "\\";
var cf = "⟈";
var af = "•";
var lf = "•";
var uf = "≎";
var ff = "⪮";
var pf = "≏";
var hf = "≎";
var df = "≏";
var gf = "Ć";
var mf = "ć";
var _f = "⩄";
var bf = "⩉";
var vf = "⩋";
var kf = "∩";
var xf = "⋒";
var yf = "⩇";
var Ef = "⩀";
var wf = "ⅅ";
var Af = "∩︀";
var Cf = "⁁";
var Sf = "ˇ";
var Df = "ℭ";
var Tf = "⩍";
var Rf = "Č";
var Lf = "č";
var Nf = "Ç";
var qf = "ç";
var Mf = "Ĉ";
var If = "ĉ";
var Of = "∰";
var Ff = "⩌";
var Bf = "⩐";
var Pf = "Ċ";
var $f = "ċ";
var zf = "¸";
var Uf = "¸";
var Hf = "⦲";
var Vf = "¢";
var Gf = "·";
var jf = "·";
var Zf = "𝔠";
var Kf = "ℭ";
var Wf = "Ч";
var Yf = "ч";
var Jf = "✓";
var Xf = "✓";
var Qf = "Χ";
var ep = "χ";
var np = "ˆ";
var tp = "≗";
var rp = "↺";
var op = "↻";
var sp = "⊛";
var cp = "⊚";
var ip = "⊝";
var ap = "⊙";
var lp = "®";
var up = "Ⓢ";
var fp = "⊖";
var pp = "⊕";
var hp = "⊗";
var dp = "○";
var gp = "⧃";
var mp = "≗";
var _p = "⨐";
var bp = "⫯";
var vp = "⧂";
var kp = "∲";
var xp = "”";
var yp = "’";
var Ep = "♣";
var wp = "♣";
var Ap = ":";
var Cp = "∷";
var Sp = "⩴";
var Dp = "≔";
var Tp = "≔";
var Rp = ",";
var Lp = "@";
var Np = "∁";
var qp = "∘";
var Mp = "∁";
var Ip = "ℂ";
var Op = "≅";
var Fp = "⩭";
var Bp = "≡";
var Pp = "∮";
var $p = "∯";
var zp = "∮";
var Up = "𝕔";
var Hp = "ℂ";
var Vp = "∐";
var Gp = "∐";
var jp = "©";
var Zp = "©";
var Kp = "℗";
var Wp = "∳";
var Yp = "↵";
var Jp = "✗";
var Xp = "⨯";
var Qp = "𝒞";
var eh = "𝒸";
var nh = "⫏";
var th = "⫑";
var rh = "⫐";
var oh = "⫒";
var sh = "⋯";
var ch = "⤸";
var ih = "⤵";
var ah = "⋞";
var lh = "⋟";
var uh = "↶";
var fh = "⤽";
var ph = "⩈";
var hh = "⩆";
var dh = "≍";
var gh = "∪";
var mh = "⋓";
var _h = "⩊";
var bh = "⊍";
var vh = "⩅";
var kh = "∪︀";
var xh = "↷";
var yh = "⤼";
var Eh = "⋞";
var wh = "⋟";
var Ah = "⋎";
var Ch = "⋏";
var Sh = "¤";
var Dh = "↶";
var Th = "↷";
var Rh = "⋎";
var Lh = "⋏";
var Nh = "∲";
var qh = "∱";
var Mh = "⌭";
var Ih = "†";
var Oh = "‡";
var Fh = "ℸ";
var Bh = "↓";
var Ph = "↡";
var $h = "⇓";
var zh = "‐";
var Uh = "⫤";
var Hh = "⊣";
var Vh = "⤏";
var Gh = "˝";
var jh = "Ď";
var Zh = "ď";
var Kh = "Д";
var Wh = "д";
var Yh = "‡";
var Jh = "⇊";
var Xh = "ⅅ";
var Qh = "ⅆ";
var ed = "⤑";
var nd = "⩷";
var td = "°";
var rd = "∇";
var od = "Δ";
var sd = "δ";
var cd = "⦱";
var id = "⥿";
var ad = "𝔇";
var ld = "𝔡";
var ud = "⥥";
var fd = "⇃";
var pd = "⇂";
var hd = "´";
var dd = "˙";
var gd = "˝";
var md = "`";
var _d = "˜";
var bd = "⋄";
var vd = "⋄";
var kd = "⋄";
var xd = "♦";
var yd = "♦";
var Ed = "¨";
var wd = "ⅆ";
var Ad = "ϝ";
var Cd = "⋲";
var Sd = "÷";
var Dd = "÷";
var Td = "⋇";
var Rd = "⋇";
var Ld = "Ђ";
var Nd = "ђ";
var qd = "⌞";
var Md = "⌍";
var Id = "$";
var Od = "𝔻";
var Fd = "𝕕";
var Bd = "¨";
var Pd = "˙";
var $d = "⃜";
var zd = "≐";
var Ud = "≑";
var Hd = "≐";
var Vd = "∸";
var Gd = "∔";
var jd = "⊡";
var Zd = "⌆";
var Kd = "∯";
var Wd = "¨";
var Yd = "⇓";
var Jd = "⇐";
var Xd = "⇔";
var Qd = "⫤";
var eg = "⟸";
var ng = "⟺";
var tg = "⟹";
var rg = "⇒";
var og = "⊨";
var sg = "⇑";
var cg = "⇕";
var ig = "∥";
var ag = "⤓";
var lg = "↓";
var ug = "↓";
var fg = "⇓";
var pg = "⇵";
var hg = "̑";
var dg = "⇊";
var gg = "⇃";
var mg = "⇂";
var _g = "⥐";
var bg = "⥞";
var vg = "⥖";
var kg = "↽";
var xg = "⥟";
var yg = "⥗";
var Eg = "⇁";
var wg = "↧";
var Ag = "⊤";
var Cg = "⤐";
var Sg = "⌟";
var Dg = "⌌";
var Tg = "𝒟";
var Rg = "𝒹";
var Lg = "Ѕ";
var Ng = "ѕ";
var qg = "⧶";
var Mg = "Đ";
var Ig = "đ";
var Og = "⋱";
var Fg = "▿";
var Bg = "▾";
var Pg = "⇵";
var $g = "⥯";
var zg = "⦦";
var Ug = "Џ";
var Hg = "џ";
var Vg = "⟿";
var Gg = "É";
var jg = "é";
var Zg = "⩮";
var Kg = "Ě";
var Wg = "ě";
var Yg = "Ê";
var Jg = "ê";
var Xg = "≖";
var Qg = "≕";
var em = "Э";
var nm = "э";
var tm = "⩷";
var rm = "Ė";
var om = "ė";
var sm = "≑";
var cm = "ⅇ";
var im = "≒";
var am = "𝔈";
var lm = "𝔢";
var um = "⪚";
var fm = "È";
var pm = "è";
var hm = "⪖";
var dm = "⪘";
var gm = "⪙";
var mm = "∈";
var _m = "⏧";
var bm = "ℓ";
var vm = "⪕";
var km = "⪗";
var xm = "Ē";
var ym = "ē";
var Em = "∅";
var wm = "∅";
var Am = "◻";
var Cm = "∅";
var Sm = "▫";
var Dm = " ";
var Tm = " ";
var Rm = " ";
var Lm = "Ŋ";
var Nm = "ŋ";
var qm = " ";
var Mm = "Ę";
var Im = "ę";
var Om = "𝔼";
var Fm = "𝕖";
var Bm = "⋕";
var Pm = "⧣";
var $m = "⩱";
var zm = "ε";
var Um = "Ε";
var Hm = "ε";
var Vm = "ϵ";
var Gm = "≖";
var jm = "≕";
var Zm = "≂";
var Km = "⪖";
var Wm = "⪕";
var Ym = "⩵";
var Jm = "=";
var Xm = "≂";
var Qm = "≟";
var e_ = "⇌";
var n_ = "≡";
var t_ = "⩸";
var r_ = "⧥";
var o_ = "⥱";
var s_ = "≓";
var c_ = "ℯ";
var i_ = "ℰ";
var a_ = "≐";
var l_ = "⩳";
var u_ = "≂";
var f_ = "Η";
var p_ = "η";
var h_ = "Ð";
var d_ = "ð";
var g_ = "Ë";
var m_ = "ë";
var __ = "€";
var b_ = "!";
var v_ = "∃";
var k_ = "∃";
var x_ = "ℰ";
var y_ = "ⅇ";
var E_ = "ⅇ";
var w_ = "≒";
var A_ = "Ф";
var C_ = "ф";
var S_ = "♀";
var D_ = "ﬃ";
var T_ = "ﬀ";
var R_ = "ﬄ";
var L_ = "𝔉";
var N_ = "𝔣";
var q_ = "ﬁ";
var M_ = "◼";
var I_ = "▪";
var O_ = "fj";
var F_ = "♭";
var B_ = "ﬂ";
var P_ = "▱";
var $_ = "ƒ";
var z_ = "𝔽";
var U_ = "𝕗";
var H_ = "∀";
var V_ = "∀";
var G_ = "⋔";
var j_ = "⫙";
var Z_ = "ℱ";
var K_ = "⨍";
var W_ = "½";
var Y_ = "⅓";
var J_ = "¼";
var X_ = "⅕";
var Q_ = "⅙";
var eb = "⅛";
var nb = "⅔";
var tb = "⅖";
var rb = "¾";
var ob = "⅗";
var sb = "⅜";
var cb = "⅘";
var ib = "⅚";
var ab = "⅝";
var lb = "⅞";
var ub = "⁄";
var fb = "⌢";
var pb = "𝒻";
var hb = "ℱ";
var db = "ǵ";
var gb = "Γ";
var mb = "γ";
var _b = "Ϝ";
var bb = "ϝ";
var vb = "⪆";
var kb = "Ğ";
var xb = "ğ";
var yb = "Ģ";
var Eb = "Ĝ";
var wb = "ĝ";
var Ab = "Г";
var Cb = "г";
var Sb = "Ġ";
var Db = "ġ";
var Tb = "≥";
var Rb = "≧";
var Lb = "⪌";
var Nb = "⋛";
var qb = "≥";
var Mb = "≧";
var Ib = "⩾";
var Ob = "⪩";
var Fb = "⩾";
var Bb = "⪀";
var Pb = "⪂";
var $b = "⪄";
var zb = "⋛︀";
var Ub = "⪔";
var Hb = "𝔊";
var Vb = "𝔤";
var Gb = "≫";
var jb = "⋙";
var Zb = "⋙";
var Kb = "ℷ";
var Wb = "Ѓ";
var Yb = "ѓ";
var Jb = "⪥";
var Xb = "≷";
var Qb = "⪒";
var e0 = "⪤";
var n0 = "⪊";
var t0 = "⪊";
var r0 = "⪈";
var o0 = "≩";
var s0 = "⪈";
var c0 = "≩";
var i0 = "⋧";
var a0 = "𝔾";
var l0 = "𝕘";
var u0 = "`";
var f0 = "≥";
var p0 = "⋛";
var h0 = "≧";
var d0 = "⪢";
var g0 = "≷";
var m0 = "⩾";
var _0 = "≳";
var b0 = "𝒢";
var v0 = "ℊ";
var k0 = "≳";
var x0 = "⪎";
var y0 = "⪐";
var E0 = "⪧";
var w0 = "⩺";
var A0 = ">";
var C0 = ">";
var S0 = "≫";
var D0 = "⋗";
var T0 = "⦕";
var R0 = "⩼";
var L0 = "⪆";
var N0 = "⥸";
var q0 = "⋗";
var M0 = "⋛";
var I0 = "⪌";
var O0 = "≷";
var F0 = "≳";
var B0 = "≩︀";
var P0 = "≩︀";
var $0 = "ˇ";
var z0 = " ";
var U0 = "½";
var H0 = "ℋ";
var V0 = "Ъ";
var G0 = "ъ";
var j0 = "⥈";
var Z0 = "↔";
var K0 = "⇔";
var W0 = "↭";
var Y0 = "^";
var J0 = "ℏ";
var X0 = "Ĥ";
var Q0 = "ĥ";
var ev = "♥";
var nv = "♥";
var tv = "…";
var rv = "⊹";
var ov = "𝔥";
var sv = "ℌ";
var cv = "ℋ";
var iv = "⤥";
var av = "⤦";
var lv = "⇿";
var uv = "∻";
var fv = "↩";
var pv = "↪";
var hv = "𝕙";
var dv = "ℍ";
var gv = "―";
var mv = "─";
var _v = "𝒽";
var bv = "ℋ";
var vv = "ℏ";
var kv = "Ħ";
var xv = "ħ";
var yv = "≎";
var Ev = "≏";
var wv = "⁃";
var Av = "‐";
var Cv = "Í";
var Sv = "í";
var Dv = "⁣";
var Tv = "Î";
var Rv = "î";
var Lv = "И";
var Nv = "и";
var qv = "İ";
var Mv = "Е";
var Iv = "е";
var Ov = "¡";
var Fv = "⇔";
var Bv = "𝔦";
var Pv = "ℑ";
var $v = "Ì";
var zv = "ì";
var Uv = "ⅈ";
var Hv = "⨌";
var Vv = "∭";
var Gv = "⧜";
var jv = "℩";
var Zv = "Ĳ";
var Kv = "ĳ";
var Wv = "Ī";
var Yv = "ī";
var Jv = "ℑ";
var Xv = "ⅈ";
var Qv = "ℐ";
var ek = "ℑ";
var nk = "ı";
var tk = "ℑ";
var rk = "⊷";
var ok = "Ƶ";
var sk = "⇒";
var ck = "℅";
var ik = "∞";
var ak = "⧝";
var lk = "ı";
var uk = "⊺";
var fk = "∫";
var pk = "∬";
var hk = "ℤ";
var dk = "∫";
var gk = "⊺";
var mk = "⋂";
var _k = "⨗";
var bk = "⨼";
var vk = "⁣";
var kk = "⁢";
var xk = "Ё";
var yk = "ё";
var Ek = "Į";
var wk = "į";
var Ak = "𝕀";
var Ck = "𝕚";
var Sk = "Ι";
var Dk = "ι";
var Tk = "⨼";
var Rk = "¿";
var Lk = "𝒾";
var Nk = "ℐ";
var qk = "∈";
var Mk = "⋵";
var Ik = "⋹";
var Ok = "⋴";
var Fk = "⋳";
var Bk = "∈";
var Pk = "⁢";
var $k = "Ĩ";
var zk = "ĩ";
var Uk = "І";
var Hk = "і";
var Vk = "Ï";
var Gk = "ï";
var jk = "Ĵ";
var Zk = "ĵ";
var Kk = "Й";
var Wk = "й";
var Yk = "𝔍";
var Jk = "𝔧";
var Xk = "ȷ";
var Qk = "𝕁";
var ex = "𝕛";
var nx = "𝒥";
var tx = "𝒿";
var rx = "Ј";
var ox = "ј";
var sx = "Є";
var cx = "є";
var ix = "Κ";
var ax = "κ";
var lx = "ϰ";
var ux = "Ķ";
var fx = "ķ";
var px = "К";
var hx = "к";
var dx = "𝔎";
var gx = "𝔨";
var mx = "ĸ";
var _x = "Х";
var bx = "х";
var vx = "Ќ";
var kx = "ќ";
var xx = "𝕂";
var yx = "𝕜";
var Ex = "𝒦";
var wx = "𝓀";
var Ax = "⇚";
var Cx = "Ĺ";
var Sx = "ĺ";
var Dx = "⦴";
var Tx = "ℒ";
var Rx = "Λ";
var Lx = "λ";
var Nx = "⟨";
var qx = "⟪";
var Mx = "⦑";
var Ix = "⟨";
var Ox = "⪅";
var Fx = "ℒ";
var Bx = "«";
var Px = "⇤";
var $x = "⤟";
var zx = "←";
var Ux = "↞";
var Hx = "⇐";
var Vx = "⤝";
var Gx = "↩";
var jx = "↫";
var Zx = "⤹";
var Kx = "⥳";
var Wx = "↢";
var Yx = "⤙";
var Jx = "⤛";
var Xx = "⪫";
var Qx = "⪭";
var ey = "⪭︀";
var ny = "⤌";
var ty = "⤎";
var ry = "❲";
var oy = "{";
var sy = "[";
var cy = "⦋";
var iy = "⦏";
var ay = "⦍";
var ly = "Ľ";
var uy = "ľ";
var fy = "Ļ";
var py = "ļ";
var hy = "⌈";
var dy = "{";
var gy = "Л";
var my = "л";
var _y = "⤶";
var by = "“";
var vy = "„";
var ky = "⥧";
var xy = "⥋";
var yy = "↲";
var Ey = "≤";
var wy = "≦";
var Ay = "⟨";
var Cy = "⇤";
var Sy = "←";
var Dy = "←";
var Ty = "⇐";
var Ry = "⇆";
var Ly = "↢";
var Ny = "⌈";
var qy = "⟦";
var My = "⥡";
var Iy = "⥙";
var Oy = "⇃";
var Fy = "⌊";
var By = "↽";
var Py = "↼";
var $y = "⇇";
var zy = "↔";
var Uy = "↔";
var Hy = "⇔";
var Vy = "⇆";
var Gy = "⇋";
var jy = "↭";
var Zy = "⥎";
var Ky = "↤";
var Wy = "⊣";
var Yy = "⥚";
var Jy = "⋋";
var Xy = "⧏";
var Qy = "⊲";
var eE = "⊴";
var nE = "⥑";
var tE = "⥠";
var rE = "⥘";
var oE = "↿";
var sE = "⥒";
var cE = "↼";
var iE = "⪋";
var aE = "⋚";
var lE = "≤";
var uE = "≦";
var fE = "⩽";
var pE = "⪨";
var hE = "⩽";
var dE = "⩿";
var gE = "⪁";
var mE = "⪃";
var _E = "⋚︀";
var bE = "⪓";
var vE = "⪅";
var kE = "⋖";
var xE = "⋚";
var yE = "⪋";
var EE = "⋚";
var wE = "≦";
var AE = "≶";
var CE = "≶";
var SE = "⪡";
var DE = "≲";
var TE = "⩽";
var RE = "≲";
var LE = "⥼";
var NE = "⌊";
var qE = "𝔏";
var ME = "𝔩";
var IE = "≶";
var OE = "⪑";
var FE = "⥢";
var BE = "↽";
var PE = "↼";
var $E = "⥪";
var zE = "▄";
var UE = "Љ";
var HE = "љ";
var VE = "⇇";
var GE = "≪";
var jE = "⋘";
var ZE = "⌞";
var KE = "⇚";
var WE = "⥫";
var YE = "◺";
var JE = "Ŀ";
var XE = "ŀ";
var QE = "⎰";
var ew = "⎰";
var nw = "⪉";
var tw = "⪉";
var rw = "⪇";
var ow = "≨";
var sw = "⪇";
var cw = "≨";
var iw = "⋦";
var aw = "⟬";
var lw = "⇽";
var uw = "⟦";
var fw = "⟵";
var pw = "⟵";
var hw = "⟸";
var dw = "⟷";
var gw = "⟷";
var mw = "⟺";
var _w = "⟼";
var bw = "⟶";
var vw = "⟶";
var kw = "⟹";
var xw = "↫";
var yw = "↬";
var Ew = "⦅";
var ww = "𝕃";
var Aw = "𝕝";
var Cw = "⨭";
var Sw = "⨴";
var Dw = "∗";
var Tw = "_";
var Rw = "↙";
var Lw = "↘";
var Nw = "◊";
var qw = "◊";
var Mw = "⧫";
var Iw = "(";
var Ow = "⦓";
var Fw = "⇆";
var Bw = "⌟";
var Pw = "⇋";
var $w = "⥭";
var zw = "‎";
var Uw = "⊿";
var Hw = "‹";
var Vw = "𝓁";
var Gw = "ℒ";
var jw = "↰";
var Zw = "↰";
var Kw = "≲";
var Ww = "⪍";
var Yw = "⪏";
var Jw = "[";
var Xw = "‘";
var Qw = "‚";
var e1 = "Ł";
var n1 = "ł";
var t1 = "⪦";
var r1 = "⩹";
var o1 = "<";
var s1 = "<";
var c1 = "≪";
var i1 = "⋖";
var a1 = "⋋";
var l1 = "⋉";
var u1 = "⥶";
var f1 = "⩻";
var p1 = "◃";
var h1 = "⊴";
var d1 = "◂";
var g1 = "⦖";
var m1 = "⥊";
var _1 = "⥦";
var b1 = "≨︀";
var v1 = "≨︀";
var k1 = "¯";
var x1 = "♂";
var y1 = "✠";
var E1 = "✠";
var w1 = "↦";
var A1 = "↦";
var C1 = "↧";
var S1 = "↤";
var D1 = "↥";
var T1 = "▮";
var R1 = "⨩";
var L1 = "М";
var N1 = "м";
var q1 = "—";
var M1 = "∺";
var I1 = "∡";
var O1 = " ";
var F1 = "ℳ";
var B1 = "𝔐";
var P1 = "𝔪";
var $1 = "℧";
var z1 = "µ";
var U1 = "*";
var H1 = "⫰";
var V1 = "∣";
var G1 = "·";
var j1 = "⊟";
var Z1 = "−";
var K1 = "∸";
var W1 = "⨪";
var Y1 = "∓";
var J1 = "⫛";
var X1 = "…";
var Q1 = "∓";
var eA = "⊧";
var nA = "𝕄";
var tA = "𝕞";
var rA = "∓";
var oA = "𝓂";
var sA = "ℳ";
var cA = "∾";
var iA = "Μ";
var aA = "μ";
var lA = "⊸";
var uA = "⊸";
var fA = "∇";
var pA = "Ń";
var hA = "ń";
var dA = "∠⃒";
var gA = "≉";
var mA = "⩰̸";
var _A = "≋̸";
var bA = "ŉ";
var vA = "≉";
var kA = "♮";
var xA = "ℕ";
var yA = "♮";
var EA = " ";
var wA = "≎̸";
var AA = "≏̸";
var CA = "⩃";
var SA = "Ň";
var DA = "ň";
var TA = "Ņ";
var RA = "ņ";
var LA = "≇";
var NA = "⩭̸";
var qA = "⩂";
var MA = "Н";
var IA = "н";
var OA = "–";
var FA = "⤤";
var BA = "↗";
var PA = "⇗";
var $A = "↗";
var zA = "≠";
var UA = "≐̸";
var HA = "​";
var VA = "​";
var GA = "​";
var jA = "​";
var ZA = "≢";
var KA = "⤨";
var WA = "≂̸";
var YA = "≫";
var JA = "≪";
var XA = `
`;
var QA = "∄";
var eC = "∄";
var nC = "𝔑";
var tC = "𝔫";
var rC = "≧̸";
var oC = "≱";
var sC = "≱";
var cC = "≧̸";
var iC = "⩾̸";
var aC = "⩾̸";
var lC = "⋙̸";
var uC = "≵";
var fC = "≫⃒";
var pC = "≯";
var hC = "≯";
var dC = "≫̸";
var gC = "↮";
var mC = "⇎";
var _C = "⫲";
var bC = "∋";
var vC = "⋼";
var kC = "⋺";
var xC = "∋";
var yC = "Њ";
var EC = "њ";
var wC = "↚";
var AC = "⇍";
var CC = "‥";
var SC = "≦̸";
var DC = "≰";
var TC = "↚";
var RC = "⇍";
var LC = "↮";
var NC = "⇎";
var qC = "≰";
var MC = "≦̸";
var IC = "⩽̸";
var OC = "⩽̸";
var FC = "≮";
var BC = "⋘̸";
var PC = "≴";
var $C = "≪⃒";
var zC = "≮";
var UC = "⋪";
var HC = "⋬";
var VC = "≪̸";
var GC = "∤";
var jC = "⁠";
var ZC = " ";
var KC = "𝕟";
var WC = "ℕ";
var YC = "⫬";
var JC = "¬";
var XC = "≢";
var QC = "≭";
var eS = "∦";
var nS = "∉";
var tS = "≠";
var rS = "≂̸";
var oS = "∄";
var sS = "≯";
var cS = "≱";
var iS = "≧̸";
var aS = "≫̸";
var lS = "≹";
var uS = "⩾̸";
var fS = "≵";
var pS = "≎̸";
var hS = "≏̸";
var dS = "∉";
var gS = "⋵̸";
var mS = "⋹̸";
var _S = "∉";
var bS = "⋷";
var vS = "⋶";
var kS = "⧏̸";
var xS = "⋪";
var yS = "⋬";
var ES = "≮";
var wS = "≰";
var AS = "≸";
var CS = "≪̸";
var SS = "⩽̸";
var DS = "≴";
var TS = "⪢̸";
var RS = "⪡̸";
var LS = "∌";
var NS = "∌";
var qS = "⋾";
var MS = "⋽";
var IS = "⊀";
var OS = "⪯̸";
var FS = "⋠";
var BS = "∌";
var PS = "⧐̸";
var $S = "⋫";
var zS = "⋭";
var US = "⊏̸";
var HS = "⋢";
var VS = "⊐̸";
var GS = "⋣";
var jS = "⊂⃒";
var ZS = "⊈";
var KS = "⊁";
var WS = "⪰̸";
var YS = "⋡";
var JS = "≿̸";
var XS = "⊃⃒";
var QS = "⊉";
var eD = "≁";
var nD = "≄";
var tD = "≇";
var rD = "≉";
var oD = "∤";
var sD = "∦";
var cD = "∦";
var iD = "⫽⃥";
var aD = "∂̸";
var lD = "⨔";
var uD = "⊀";
var fD = "⋠";
var pD = "⊀";
var hD = "⪯̸";
var dD = "⪯̸";
var gD = "⤳̸";
var mD = "↛";
var _D = "⇏";
var bD = "↝̸";
var vD = "↛";
var kD = "⇏";
var xD = "⋫";
var yD = "⋭";
var ED = "⊁";
var wD = "⋡";
var AD = "⪰̸";
var CD = "𝒩";
var SD = "𝓃";
var DD = "∤";
var TD = "∦";
var RD = "≁";
var LD = "≄";
var ND = "≄";
var qD = "∤";
var MD = "∦";
var ID = "⋢";
var OD = "⋣";
var FD = "⊄";
var BD = "⫅̸";
var PD = "⊈";
var $D = "⊂⃒";
var zD = "⊈";
var UD = "⫅̸";
var HD = "⊁";
var VD = "⪰̸";
var GD = "⊅";
var jD = "⫆̸";
var ZD = "⊉";
var KD = "⊃⃒";
var WD = "⊉";
var YD = "⫆̸";
var JD = "≹";
var XD = "Ñ";
var QD = "ñ";
var eT = "≸";
var nT = "⋪";
var tT = "⋬";
var rT = "⋫";
var oT = "⋭";
var sT = "Ν";
var cT = "ν";
var iT = "#";
var aT = "№";
var lT = " ";
var uT = "≍⃒";
var fT = "⊬";
var pT = "⊭";
var hT = "⊮";
var dT = "⊯";
var gT = "≥⃒";
var mT = ">⃒";
var _T = "⤄";
var bT = "⧞";
var vT = "⤂";
var kT = "≤⃒";
var xT = "<⃒";
var yT = "⊴⃒";
var ET = "⤃";
var wT = "⊵⃒";
var AT = "∼⃒";
var CT = "⤣";
var ST = "↖";
var DT = "⇖";
var TT = "↖";
var RT = "⤧";
var LT = "Ó";
var NT = "ó";
var qT = "⊛";
var MT = "Ô";
var IT = "ô";
var OT = "⊚";
var FT = "О";
var BT = "о";
var PT = "⊝";
var $T = "Ő";
var zT = "ő";
var UT = "⨸";
var HT = "⊙";
var VT = "⦼";
var GT = "Œ";
var jT = "œ";
var ZT = "⦿";
var KT = "𝔒";
var WT = "𝔬";
var YT = "˛";
var JT = "Ò";
var XT = "ò";
var QT = "⧁";
var eR = "⦵";
var nR = "Ω";
var tR = "∮";
var rR = "↺";
var oR = "⦾";
var sR = "⦻";
var cR = "‾";
var iR = "⧀";
var aR = "Ō";
var lR = "ō";
var uR = "Ω";
var fR = "ω";
var pR = "Ο";
var hR = "ο";
var dR = "⦶";
var gR = "⊖";
var mR = "𝕆";
var _R = "𝕠";
var bR = "⦷";
var vR = "“";
var kR = "‘";
var xR = "⦹";
var yR = "⊕";
var ER = "↻";
var wR = "⩔";
var AR = "∨";
var CR = "⩝";
var SR = "ℴ";
var DR = "ℴ";
var TR = "ª";
var RR = "º";
var LR = "⊶";
var NR = "⩖";
var qR = "⩗";
var MR = "⩛";
var IR = "Ⓢ";
var OR = "𝒪";
var FR = "ℴ";
var BR = "Ø";
var PR = "ø";
var $R = "⊘";
var zR = "Õ";
var UR = "õ";
var HR = "⨶";
var VR = "⨷";
var GR = "⊗";
var jR = "Ö";
var ZR = "ö";
var KR = "⌽";
var WR = "‾";
var YR = "⏞";
var JR = "⎴";
var XR = "⏜";
var QR = "¶";
var e2 = "∥";
var n2 = "∥";
var t2 = "⫳";
var r2 = "⫽";
var o2 = "∂";
var s2 = "∂";
var c2 = "П";
var i2 = "п";
var a2 = "%";
var l2 = ".";
var u2 = "‰";
var f2 = "⊥";
var p2 = "‱";
var h2 = "𝔓";
var d2 = "𝔭";
var g2 = "Φ";
var m2 = "φ";
var _2 = "ϕ";
var b2 = "ℳ";
var v2 = "☎";
var k2 = "Π";
var x2 = "π";
var y2 = "⋔";
var E2 = "ϖ";
var w2 = "ℏ";
var A2 = "ℎ";
var C2 = "ℏ";
var S2 = "⨣";
var D2 = "⊞";
var T2 = "⨢";
var R2 = "+";
var L2 = "∔";
var N2 = "⨥";
var q2 = "⩲";
var M2 = "±";
var I2 = "±";
var O2 = "⨦";
var F2 = "⨧";
var B2 = "±";
var P2 = "ℌ";
var $2 = "⨕";
var z2 = "𝕡";
var U2 = "ℙ";
var H2 = "£";
var V2 = "⪷";
var G2 = "⪻";
var j2 = "≺";
var Z2 = "≼";
var K2 = "⪷";
var W2 = "≺";
var Y2 = "≼";
var J2 = "≺";
var X2 = "⪯";
var Q2 = "≼";
var eL = "≾";
var nL = "⪯";
var tL = "⪹";
var rL = "⪵";
var oL = "⋨";
var sL = "⪯";
var cL = "⪳";
var iL = "≾";
var aL = "′";
var lL = "″";
var uL = "ℙ";
var fL = "⪹";
var pL = "⪵";
var hL = "⋨";
var dL = "∏";
var gL = "∏";
var mL = "⌮";
var _L = "⌒";
var bL = "⌓";
var vL = "∝";
var kL = "∝";
var xL = "∷";
var yL = "∝";
var EL = "≾";
var wL = "⊰";
var AL = "𝒫";
var CL = "𝓅";
var SL = "Ψ";
var DL = "ψ";
var TL = " ";
var RL = "𝔔";
var LL = "𝔮";
var NL = "⨌";
var qL = "𝕢";
var ML = "ℚ";
var IL = "⁗";
var OL = "𝒬";
var FL = "𝓆";
var BL = "ℍ";
var PL = "⨖";
var $L = "?";
var zL = "≟";
var UL = '"';
var HL = '"';
var VL = "⇛";
var GL = "∽̱";
var jL = "Ŕ";
var ZL = "ŕ";
var KL = "√";
var WL = "⦳";
var YL = "⟩";
var JL = "⟫";
var XL = "⦒";
var QL = "⦥";
var eN = "⟩";
var nN = "»";
var tN = "⥵";
var rN = "⇥";
var oN = "⤠";
var sN = "⤳";
var cN = "→";
var iN = "↠";
var aN = "⇒";
var lN = "⤞";
var uN = "↪";
var fN = "↬";
var pN = "⥅";
var hN = "⥴";
var dN = "⤖";
var gN = "↣";
var mN = "↝";
var _N = "⤚";
var bN = "⤜";
var vN = "∶";
var kN = "ℚ";
var xN = "⤍";
var yN = "⤏";
var EN = "⤐";
var wN = "❳";
var AN = "}";
var CN = "]";
var SN = "⦌";
var DN = "⦎";
var TN = "⦐";
var RN = "Ř";
var LN = "ř";
var NN = "Ŗ";
var qN = "ŗ";
var MN = "⌉";
var IN = "}";
var ON = "Р";
var FN = "р";
var BN = "⤷";
var PN = "⥩";
var $N = "”";
var zN = "”";
var UN = "↳";
var HN = "ℜ";
var VN = "ℛ";
var GN = "ℜ";
var jN = "ℝ";
var ZN = "ℜ";
var KN = "▭";
var WN = "®";
var YN = "®";
var JN = "∋";
var XN = "⇋";
var QN = "⥯";
var eq = "⥽";
var nq = "⌋";
var tq = "𝔯";
var rq = "ℜ";
var oq = "⥤";
var sq = "⇁";
var cq = "⇀";
var iq = "⥬";
var aq = "Ρ";
var lq = "ρ";
var uq = "ϱ";
var fq = "⟩";
var pq = "⇥";
var hq = "→";
var dq = "→";
var gq = "⇒";
var mq = "⇄";
var _q = "↣";
var bq = "⌉";
var vq = "⟧";
var kq = "⥝";
var xq = "⥕";
var yq = "⇂";
var Eq = "⌋";
var wq = "⇁";
var Aq = "⇀";
var Cq = "⇄";
var Sq = "⇌";
var Dq = "⇉";
var Tq = "↝";
var Rq = "↦";
var Lq = "⊢";
var Nq = "⥛";
var qq = "⋌";
var Mq = "⧐";
var Iq = "⊳";
var Oq = "⊵";
var Fq = "⥏";
var Bq = "⥜";
var Pq = "⥔";
var $q = "↾";
var zq = "⥓";
var Uq = "⇀";
var Hq = "˚";
var Vq = "≓";
var Gq = "⇄";
var jq = "⇌";
var Zq = "‏";
var Kq = "⎱";
var Wq = "⎱";
var Yq = "⫮";
var Jq = "⟭";
var Xq = "⇾";
var Qq = "⟧";
var eM = "⦆";
var nM = "𝕣";
var tM = "ℝ";
var rM = "⨮";
var oM = "⨵";
var sM = "⥰";
var cM = ")";
var iM = "⦔";
var aM = "⨒";
var lM = "⇉";
var uM = "⇛";
var fM = "›";
var pM = "𝓇";
var hM = "ℛ";
var dM = "↱";
var gM = "↱";
var mM = "]";
var _M = "’";
var bM = "’";
var vM = "⋌";
var kM = "⋊";
var xM = "▹";
var yM = "⊵";
var EM = "▸";
var wM = "⧎";
var AM = "⧴";
var CM = "⥨";
var SM = "℞";
var DM = "Ś";
var TM = "ś";
var RM = "‚";
var LM = "⪸";
var NM = "Š";
var qM = "š";
var MM = "⪼";
var IM = "≻";
var OM = "≽";
var FM = "⪰";
var BM = "⪴";
var PM = "Ş";
var $M = "ş";
var zM = "Ŝ";
var UM = "ŝ";
var HM = "⪺";
var VM = "⪶";
var GM = "⋩";
var jM = "⨓";
var ZM = "≿";
var KM = "С";
var WM = "с";
var YM = "⊡";
var JM = "⋅";
var XM = "⩦";
var QM = "⤥";
var eI = "↘";
var nI = "⇘";
var tI = "↘";
var rI = "§";
var oI = ";";
var sI = "⤩";
var cI = "∖";
var iI = "∖";
var aI = "✶";
var lI = "𝔖";
var uI = "𝔰";
var fI = "⌢";
var pI = "♯";
var hI = "Щ";
var dI = "щ";
var gI = "Ш";
var mI = "ш";
var _I = "↓";
var bI = "←";
var vI = "∣";
var kI = "∥";
var xI = "→";
var yI = "↑";
var EI = "­";
var wI = "Σ";
var AI = "σ";
var CI = "ς";
var SI = "ς";
var DI = "∼";
var TI = "⩪";
var RI = "≃";
var LI = "≃";
var NI = "⪞";
var qI = "⪠";
var MI = "⪝";
var II = "⪟";
var OI = "≆";
var FI = "⨤";
var BI = "⥲";
var PI = "←";
var $I = "∘";
var zI = "∖";
var UI = "⨳";
var HI = "⧤";
var VI = "∣";
var GI = "⌣";
var jI = "⪪";
var ZI = "⪬";
var KI = "⪬︀";
var WI = "Ь";
var YI = "ь";
var JI = "⌿";
var XI = "⧄";
var QI = "/";
var eO = "𝕊";
var nO = "𝕤";
var tO = "♠";
var rO = "♠";
var oO = "∥";
var sO = "⊓";
var cO = "⊓︀";
var iO = "⊔";
var aO = "⊔︀";
var lO = "√";
var uO = "⊏";
var fO = "⊑";
var pO = "⊏";
var hO = "⊑";
var dO = "⊐";
var gO = "⊒";
var mO = "⊐";
var _O = "⊒";
var bO = "□";
var vO = "□";
var kO = "⊓";
var xO = "⊏";
var yO = "⊑";
var EO = "⊐";
var wO = "⊒";
var AO = "⊔";
var CO = "▪";
var SO = "□";
var DO = "▪";
var TO = "→";
var RO = "𝒮";
var LO = "𝓈";
var NO = "∖";
var qO = "⌣";
var MO = "⋆";
var IO = "⋆";
var OO = "☆";
var FO = "★";
var BO = "ϵ";
var PO = "ϕ";
var $O = "¯";
var zO = "⊂";
var UO = "⋐";
var HO = "⪽";
var VO = "⫅";
var GO = "⊆";
var jO = "⫃";
var ZO = "⫁";
var KO = "⫋";
var WO = "⊊";
var YO = "⪿";
var JO = "⥹";
var XO = "⊂";
var QO = "⋐";
var eF = "⊆";
var nF = "⫅";
var tF = "⊆";
var rF = "⊊";
var oF = "⫋";
var sF = "⫇";
var cF = "⫕";
var iF = "⫓";
var aF = "⪸";
var lF = "≻";
var uF = "≽";
var fF = "≻";
var pF = "⪰";
var hF = "≽";
var dF = "≿";
var gF = "⪰";
var mF = "⪺";
var _F = "⪶";
var bF = "⋩";
var vF = "≿";
var kF = "∋";
var xF = "∑";
var yF = "∑";
var EF = "♪";
var wF = "¹";
var AF = "²";
var CF = "³";
var SF = "⊃";
var DF = "⋑";
var TF = "⪾";
var RF = "⫘";
var LF = "⫆";
var NF = "⊇";
var qF = "⫄";
var MF = "⊃";
var IF = "⊇";
var OF = "⟉";
var FF = "⫗";
var BF = "⥻";
var PF = "⫂";
var $F = "⫌";
var zF = "⊋";
var UF = "⫀";
var HF = "⊃";
var VF = "⋑";
var GF = "⊇";
var jF = "⫆";
var ZF = "⊋";
var KF = "⫌";
var WF = "⫈";
var YF = "⫔";
var JF = "⫖";
var XF = "⤦";
var QF = "↙";
var eB = "⇙";
var nB = "↙";
var tB = "⤪";
var rB = "ß";
var oB = "	";
var sB = "⌖";
var cB = "Τ";
var iB = "τ";
var aB = "⎴";
var lB = "Ť";
var uB = "ť";
var fB = "Ţ";
var pB = "ţ";
var hB = "Т";
var dB = "т";
var gB = "⃛";
var mB = "⌕";
var _B = "𝔗";
var bB = "𝔱";
var vB = "∴";
var kB = "∴";
var xB = "∴";
var yB = "Θ";
var EB = "θ";
var wB = "ϑ";
var AB = "ϑ";
var CB = "≈";
var SB = "∼";
var DB = "  ";
var TB = " ";
var RB = " ";
var LB = "≈";
var NB = "∼";
var qB = "Þ";
var MB = "þ";
var IB = "˜";
var OB = "∼";
var FB = "≃";
var BB = "≅";
var PB = "≈";
var $B = "⨱";
var zB = "⊠";
var UB = "×";
var HB = "⨰";
var VB = "∭";
var GB = "⤨";
var jB = "⌶";
var ZB = "⫱";
var KB = "⊤";
var WB = "𝕋";
var YB = "𝕥";
var JB = "⫚";
var XB = "⤩";
var QB = "‴";
var eP = "™";
var nP = "™";
var tP = "▵";
var rP = "▿";
var oP = "◃";
var sP = "⊴";
var cP = "≜";
var iP = "▹";
var aP = "⊵";
var lP = "◬";
var uP = "≜";
var fP = "⨺";
var pP = "⃛";
var hP = "⨹";
var dP = "⧍";
var gP = "⨻";
var mP = "⏢";
var _P = "𝒯";
var bP = "𝓉";
var vP = "Ц";
var kP = "ц";
var xP = "Ћ";
var yP = "ћ";
var EP = "Ŧ";
var wP = "ŧ";
var AP = "≬";
var CP = "↞";
var SP = "↠";
var DP = "Ú";
var TP = "ú";
var RP = "↑";
var LP = "↟";
var NP = "⇑";
var qP = "⥉";
var MP = "Ў";
var IP = "ў";
var OP = "Ŭ";
var FP = "ŭ";
var BP = "Û";
var PP = "û";
var $P = "У";
var zP = "у";
var UP = "⇅";
var HP = "Ű";
var VP = "ű";
var GP = "⥮";
var jP = "⥾";
var ZP = "𝔘";
var KP = "𝔲";
var WP = "Ù";
var YP = "ù";
var JP = "⥣";
var XP = "↿";
var QP = "↾";
var e$ = "▀";
var n$ = "⌜";
var t$ = "⌜";
var r$ = "⌏";
var o$ = "◸";
var s$ = "Ū";
var c$ = "ū";
var i$ = "¨";
var a$ = "_";
var l$ = "⏟";
var u$ = "⎵";
var f$ = "⏝";
var p$ = "⋃";
var h$ = "⊎";
var d$ = "Ų";
var g$ = "ų";
var m$ = "𝕌";
var _$ = "𝕦";
var b$ = "⤒";
var v$ = "↑";
var k$ = "↑";
var x$ = "⇑";
var y$ = "⇅";
var E$ = "↕";
var w$ = "↕";
var A$ = "⇕";
var C$ = "⥮";
var S$ = "↿";
var D$ = "↾";
var T$ = "⊎";
var R$ = "↖";
var L$ = "↗";
var N$ = "υ";
var q$ = "ϒ";
var M$ = "ϒ";
var I$ = "Υ";
var O$ = "υ";
var F$ = "↥";
var B$ = "⊥";
var P$ = "⇈";
var $$ = "⌝";
var z$ = "⌝";
var U$ = "⌎";
var H$ = "Ů";
var V$ = "ů";
var G$ = "◹";
var j$ = "𝒰";
var Z$ = "𝓊";
var K$ = "⋰";
var W$ = "Ũ";
var Y$ = "ũ";
var J$ = "▵";
var X$ = "▴";
var Q$ = "⇈";
var ez = "Ü";
var nz = "ü";
var tz = "⦧";
var rz = "⦜";
var oz = "ϵ";
var sz = "ϰ";
var cz = "∅";
var iz = "ϕ";
var az = "ϖ";
var lz = "∝";
var uz = "↕";
var fz = "⇕";
var pz = "ϱ";
var hz = "ς";
var dz = "⊊︀";
var gz = "⫋︀";
var mz = "⊋︀";
var _z = "⫌︀";
var bz = "ϑ";
var vz = "⊲";
var kz = "⊳";
var xz = "⫨";
var yz = "⫫";
var Ez = "⫩";
var wz = "В";
var Az = "в";
var Cz = "⊢";
var Sz = "⊨";
var Dz = "⊩";
var Tz = "⊫";
var Rz = "⫦";
var Lz = "⊻";
var Nz = "∨";
var qz = "⋁";
var Mz = "≚";
var Iz = "⋮";
var Oz = "|";
var Fz = "‖";
var Bz = "|";
var Pz = "‖";
var $z = "∣";
var zz = "|";
var Uz = "❘";
var Hz = "≀";
var Vz = " ";
var Gz = "𝔙";
var jz = "𝔳";
var Zz = "⊲";
var Kz = "⊂⃒";
var Wz = "⊃⃒";
var Yz = "𝕍";
var Jz = "𝕧";
var Xz = "∝";
var Qz = "⊳";
var e3 = "𝒱";
var n3 = "𝓋";
var t3 = "⫋︀";
var r3 = "⊊︀";
var o3 = "⫌︀";
var s3 = "⊋︀";
var c3 = "⊪";
var i3 = "⦚";
var a3 = "Ŵ";
var l3 = "ŵ";
var u3 = "⩟";
var f3 = "∧";
var p3 = "⋀";
var h3 = "≙";
var d3 = "℘";
var g3 = "𝔚";
var m3 = "𝔴";
var _3 = "𝕎";
var b3 = "𝕨";
var v3 = "℘";
var k3 = "≀";
var x3 = "≀";
var y3 = "𝒲";
var E3 = "𝓌";
var w3 = "⋂";
var A3 = "◯";
var C3 = "⋃";
var S3 = "▽";
var D3 = "𝔛";
var T3 = "𝔵";
var R3 = "⟷";
var L3 = "⟺";
var N3 = "Ξ";
var q3 = "ξ";
var M3 = "⟵";
var I3 = "⟸";
var O3 = "⟼";
var F3 = "⋻";
var B3 = "⨀";
var P3 = "𝕏";
var $3 = "𝕩";
var z3 = "⨁";
var U3 = "⨂";
var H3 = "⟶";
var V3 = "⟹";
var G3 = "𝒳";
var j3 = "𝓍";
var Z3 = "⨆";
var K3 = "⨄";
var W3 = "△";
var Y3 = "⋁";
var J3 = "⋀";
var X3 = "Ý";
var Q3 = "ý";
var eU = "Я";
var nU = "я";
var tU = "Ŷ";
var rU = "ŷ";
var oU = "Ы";
var sU = "ы";
var cU = "¥";
var iU = "𝔜";
var aU = "𝔶";
var lU = "Ї";
var uU = "ї";
var fU = "𝕐";
var pU = "𝕪";
var hU = "𝒴";
var dU = "𝓎";
var gU = "Ю";
var mU = "ю";
var _U = "ÿ";
var bU = "Ÿ";
var vU = "Ź";
var kU = "ź";
var xU = "Ž";
var yU = "ž";
var EU = "З";
var wU = "з";
var AU = "Ż";
var CU = "ż";
var SU = "ℨ";
var DU = "​";
var TU = "Ζ";
var RU = "ζ";
var LU = "𝔷";
var NU = "ℨ";
var qU = "Ж";
var MU = "ж";
var IU = "⇝";
var OU = "𝕫";
var FU = "ℤ";
var BU = "𝒵";
var PU = "𝓏";
var $U = "‍";
var zU = "‌";
var UU = {
  Aacute: wi,
  aacute: Ai,
  Abreve: Ci,
  abreve: Si,
  ac: Di,
  acd: Ti,
  acE: Ri,
  Acirc: Li,
  acirc: Ni,
  acute: qi,
  Acy: Mi,
  acy: Ii,
  AElig: Oi,
  aelig: Fi,
  af: Bi,
  Afr: Pi,
  afr: $i,
  Agrave: zi,
  agrave: Ui,
  alefsym: Hi,
  aleph: Vi,
  Alpha: Gi,
  alpha: ji,
  Amacr: Zi,
  amacr: Ki,
  amalg: Wi,
  amp: Yi,
  AMP: Ji,
  andand: Xi,
  And: Qi,
  and: ea,
  andd: na,
  andslope: ta,
  andv: ra,
  ang: oa,
  ange: sa,
  angle: ca,
  angmsdaa: ia,
  angmsdab: aa,
  angmsdac: la,
  angmsdad: ua,
  angmsdae: fa,
  angmsdaf: pa,
  angmsdag: ha,
  angmsdah: da,
  angmsd: ga,
  angrt: ma,
  angrtvb: _a,
  angrtvbd: ba,
  angsph: va,
  angst: ka,
  angzarr: xa,
  Aogon: ya,
  aogon: Ea,
  Aopf: wa,
  aopf: Aa,
  apacir: Ca,
  ap: Sa,
  apE: Da,
  ape: Ta,
  apid: Ra,
  apos: La,
  ApplyFunction: Na,
  approx: qa,
  approxeq: Ma,
  Aring: Ia,
  aring: Oa,
  Ascr: Fa,
  ascr: Ba,
  Assign: Pa,
  ast: $a,
  asymp: za,
  asympeq: Ua,
  Atilde: Ha,
  atilde: Va,
  Auml: Ga,
  auml: ja,
  awconint: Za,
  awint: Ka,
  backcong: Wa,
  backepsilon: Ya,
  backprime: Ja,
  backsim: Xa,
  backsimeq: Qa,
  Backslash: el,
  Barv: nl,
  barvee: tl,
  barwed: rl,
  Barwed: ol,
  barwedge: sl,
  bbrk: cl,
  bbrktbrk: il,
  bcong: al,
  Bcy: ll,
  bcy: ul,
  bdquo: fl,
  becaus: pl,
  because: hl,
  Because: dl,
  bemptyv: gl,
  bepsi: ml,
  bernou: _l,
  Bernoullis: bl,
  Beta: vl,
  beta: kl,
  beth: xl,
  between: yl,
  Bfr: El,
  bfr: wl,
  bigcap: Al,
  bigcirc: Cl,
  bigcup: Sl,
  bigodot: Dl,
  bigoplus: Tl,
  bigotimes: Rl,
  bigsqcup: Ll,
  bigstar: Nl,
  bigtriangledown: ql,
  bigtriangleup: Ml,
  biguplus: Il,
  bigvee: Ol,
  bigwedge: Fl,
  bkarow: Bl,
  blacklozenge: Pl,
  blacksquare: $l,
  blacktriangle: zl,
  blacktriangledown: Ul,
  blacktriangleleft: Hl,
  blacktriangleright: Vl,
  blank: Gl,
  blk12: jl,
  blk14: Zl,
  blk34: Kl,
  block: Wl,
  bne: Yl,
  bnequiv: Jl,
  bNot: Xl,
  bnot: Ql,
  Bopf: eu,
  bopf: nu,
  bot: tu,
  bottom: ru,
  bowtie: ou,
  boxbox: su,
  boxdl: cu,
  boxdL: iu,
  boxDl: au,
  boxDL: lu,
  boxdr: uu,
  boxdR: fu,
  boxDr: pu,
  boxDR: hu,
  boxh: du,
  boxH: gu,
  boxhd: mu,
  boxHd: _u,
  boxhD: bu,
  boxHD: vu,
  boxhu: ku,
  boxHu: xu,
  boxhU: yu,
  boxHU: Eu,
  boxminus: wu,
  boxplus: Au,
  boxtimes: Cu,
  boxul: Su,
  boxuL: Du,
  boxUl: Tu,
  boxUL: Ru,
  boxur: Lu,
  boxuR: Nu,
  boxUr: qu,
  boxUR: Mu,
  boxv: Iu,
  boxV: Ou,
  boxvh: Fu,
  boxvH: Bu,
  boxVh: Pu,
  boxVH: $u,
  boxvl: zu,
  boxvL: Uu,
  boxVl: Hu,
  boxVL: Vu,
  boxvr: Gu,
  boxvR: ju,
  boxVr: Zu,
  boxVR: Ku,
  bprime: Wu,
  breve: Yu,
  Breve: Ju,
  brvbar: Xu,
  bscr: Qu,
  Bscr: ef,
  bsemi: nf,
  bsim: tf,
  bsime: rf,
  bsolb: of,
  bsol: sf,
  bsolhsub: cf,
  bull: af,
  bullet: lf,
  bump: uf,
  bumpE: ff,
  bumpe: pf,
  Bumpeq: hf,
  bumpeq: df,
  Cacute: gf,
  cacute: mf,
  capand: _f,
  capbrcup: bf,
  capcap: vf,
  cap: kf,
  Cap: xf,
  capcup: yf,
  capdot: Ef,
  CapitalDifferentialD: wf,
  caps: Af,
  caret: Cf,
  caron: Sf,
  Cayleys: Df,
  ccaps: Tf,
  Ccaron: Rf,
  ccaron: Lf,
  Ccedil: Nf,
  ccedil: qf,
  Ccirc: Mf,
  ccirc: If,
  Cconint: Of,
  ccups: Ff,
  ccupssm: Bf,
  Cdot: Pf,
  cdot: $f,
  cedil: zf,
  Cedilla: Uf,
  cemptyv: Hf,
  cent: Vf,
  centerdot: Gf,
  CenterDot: jf,
  cfr: Zf,
  Cfr: Kf,
  CHcy: Wf,
  chcy: Yf,
  check: Jf,
  checkmark: Xf,
  Chi: Qf,
  chi: ep,
  circ: np,
  circeq: tp,
  circlearrowleft: rp,
  circlearrowright: op,
  circledast: sp,
  circledcirc: cp,
  circleddash: ip,
  CircleDot: ap,
  circledR: lp,
  circledS: up,
  CircleMinus: fp,
  CirclePlus: pp,
  CircleTimes: hp,
  cir: dp,
  cirE: gp,
  cire: mp,
  cirfnint: _p,
  cirmid: bp,
  cirscir: vp,
  ClockwiseContourIntegral: kp,
  CloseCurlyDoubleQuote: xp,
  CloseCurlyQuote: yp,
  clubs: Ep,
  clubsuit: wp,
  colon: Ap,
  Colon: Cp,
  Colone: Sp,
  colone: Dp,
  coloneq: Tp,
  comma: Rp,
  commat: Lp,
  comp: Np,
  compfn: qp,
  complement: Mp,
  complexes: Ip,
  cong: Op,
  congdot: Fp,
  Congruent: Bp,
  conint: Pp,
  Conint: $p,
  ContourIntegral: zp,
  copf: Up,
  Copf: Hp,
  coprod: Vp,
  Coproduct: Gp,
  copy: jp,
  COPY: Zp,
  copysr: Kp,
  CounterClockwiseContourIntegral: Wp,
  crarr: Yp,
  cross: Jp,
  Cross: Xp,
  Cscr: Qp,
  cscr: eh,
  csub: nh,
  csube: th,
  csup: rh,
  csupe: oh,
  ctdot: sh,
  cudarrl: ch,
  cudarrr: ih,
  cuepr: ah,
  cuesc: lh,
  cularr: uh,
  cularrp: fh,
  cupbrcap: ph,
  cupcap: hh,
  CupCap: dh,
  cup: gh,
  Cup: mh,
  cupcup: _h,
  cupdot: bh,
  cupor: vh,
  cups: kh,
  curarr: xh,
  curarrm: yh,
  curlyeqprec: Eh,
  curlyeqsucc: wh,
  curlyvee: Ah,
  curlywedge: Ch,
  curren: Sh,
  curvearrowleft: Dh,
  curvearrowright: Th,
  cuvee: Rh,
  cuwed: Lh,
  cwconint: Nh,
  cwint: qh,
  cylcty: Mh,
  dagger: Ih,
  Dagger: Oh,
  daleth: Fh,
  darr: Bh,
  Darr: Ph,
  dArr: $h,
  dash: zh,
  Dashv: Uh,
  dashv: Hh,
  dbkarow: Vh,
  dblac: Gh,
  Dcaron: jh,
  dcaron: Zh,
  Dcy: Kh,
  dcy: Wh,
  ddagger: Yh,
  ddarr: Jh,
  DD: Xh,
  dd: Qh,
  DDotrahd: ed,
  ddotseq: nd,
  deg: td,
  Del: rd,
  Delta: od,
  delta: sd,
  demptyv: cd,
  dfisht: id,
  Dfr: ad,
  dfr: ld,
  dHar: ud,
  dharl: fd,
  dharr: pd,
  DiacriticalAcute: hd,
  DiacriticalDot: dd,
  DiacriticalDoubleAcute: gd,
  DiacriticalGrave: md,
  DiacriticalTilde: _d,
  diam: bd,
  diamond: vd,
  Diamond: kd,
  diamondsuit: xd,
  diams: yd,
  die: Ed,
  DifferentialD: wd,
  digamma: Ad,
  disin: Cd,
  div: Sd,
  divide: Dd,
  divideontimes: Td,
  divonx: Rd,
  DJcy: Ld,
  djcy: Nd,
  dlcorn: qd,
  dlcrop: Md,
  dollar: Id,
  Dopf: Od,
  dopf: Fd,
  Dot: Bd,
  dot: Pd,
  DotDot: $d,
  doteq: zd,
  doteqdot: Ud,
  DotEqual: Hd,
  dotminus: Vd,
  dotplus: Gd,
  dotsquare: jd,
  doublebarwedge: Zd,
  DoubleContourIntegral: Kd,
  DoubleDot: Wd,
  DoubleDownArrow: Yd,
  DoubleLeftArrow: Jd,
  DoubleLeftRightArrow: Xd,
  DoubleLeftTee: Qd,
  DoubleLongLeftArrow: eg,
  DoubleLongLeftRightArrow: ng,
  DoubleLongRightArrow: tg,
  DoubleRightArrow: rg,
  DoubleRightTee: og,
  DoubleUpArrow: sg,
  DoubleUpDownArrow: cg,
  DoubleVerticalBar: ig,
  DownArrowBar: ag,
  downarrow: lg,
  DownArrow: ug,
  Downarrow: fg,
  DownArrowUpArrow: pg,
  DownBreve: hg,
  downdownarrows: dg,
  downharpoonleft: gg,
  downharpoonright: mg,
  DownLeftRightVector: _g,
  DownLeftTeeVector: bg,
  DownLeftVectorBar: vg,
  DownLeftVector: kg,
  DownRightTeeVector: xg,
  DownRightVectorBar: yg,
  DownRightVector: Eg,
  DownTeeArrow: wg,
  DownTee: Ag,
  drbkarow: Cg,
  drcorn: Sg,
  drcrop: Dg,
  Dscr: Tg,
  dscr: Rg,
  DScy: Lg,
  dscy: Ng,
  dsol: qg,
  Dstrok: Mg,
  dstrok: Ig,
  dtdot: Og,
  dtri: Fg,
  dtrif: Bg,
  duarr: Pg,
  duhar: $g,
  dwangle: zg,
  DZcy: Ug,
  dzcy: Hg,
  dzigrarr: Vg,
  Eacute: Gg,
  eacute: jg,
  easter: Zg,
  Ecaron: Kg,
  ecaron: Wg,
  Ecirc: Yg,
  ecirc: Jg,
  ecir: Xg,
  ecolon: Qg,
  Ecy: em,
  ecy: nm,
  eDDot: tm,
  Edot: rm,
  edot: om,
  eDot: sm,
  ee: cm,
  efDot: im,
  Efr: am,
  efr: lm,
  eg: um,
  Egrave: fm,
  egrave: pm,
  egs: hm,
  egsdot: dm,
  el: gm,
  Element: mm,
  elinters: _m,
  ell: bm,
  els: vm,
  elsdot: km,
  Emacr: xm,
  emacr: ym,
  empty: Em,
  emptyset: wm,
  EmptySmallSquare: Am,
  emptyv: Cm,
  EmptyVerySmallSquare: Sm,
  emsp13: Dm,
  emsp14: Tm,
  emsp: Rm,
  ENG: Lm,
  eng: Nm,
  ensp: qm,
  Eogon: Mm,
  eogon: Im,
  Eopf: Om,
  eopf: Fm,
  epar: Bm,
  eparsl: Pm,
  eplus: $m,
  epsi: zm,
  Epsilon: Um,
  epsilon: Hm,
  epsiv: Vm,
  eqcirc: Gm,
  eqcolon: jm,
  eqsim: Zm,
  eqslantgtr: Km,
  eqslantless: Wm,
  Equal: Ym,
  equals: Jm,
  EqualTilde: Xm,
  equest: Qm,
  Equilibrium: e_,
  equiv: n_,
  equivDD: t_,
  eqvparsl: r_,
  erarr: o_,
  erDot: s_,
  escr: c_,
  Escr: i_,
  esdot: a_,
  Esim: l_,
  esim: u_,
  Eta: f_,
  eta: p_,
  ETH: h_,
  eth: d_,
  Euml: g_,
  euml: m_,
  euro: __,
  excl: b_,
  exist: v_,
  Exists: k_,
  expectation: x_,
  exponentiale: y_,
  ExponentialE: E_,
  fallingdotseq: w_,
  Fcy: A_,
  fcy: C_,
  female: S_,
  ffilig: D_,
  fflig: T_,
  ffllig: R_,
  Ffr: L_,
  ffr: N_,
  filig: q_,
  FilledSmallSquare: M_,
  FilledVerySmallSquare: I_,
  fjlig: O_,
  flat: F_,
  fllig: B_,
  fltns: P_,
  fnof: $_,
  Fopf: z_,
  fopf: U_,
  forall: H_,
  ForAll: V_,
  fork: G_,
  forkv: j_,
  Fouriertrf: Z_,
  fpartint: K_,
  frac12: W_,
  frac13: Y_,
  frac14: J_,
  frac15: X_,
  frac16: Q_,
  frac18: eb,
  frac23: nb,
  frac25: tb,
  frac34: rb,
  frac35: ob,
  frac38: sb,
  frac45: cb,
  frac56: ib,
  frac58: ab,
  frac78: lb,
  frasl: ub,
  frown: fb,
  fscr: pb,
  Fscr: hb,
  gacute: db,
  Gamma: gb,
  gamma: mb,
  Gammad: _b,
  gammad: bb,
  gap: vb,
  Gbreve: kb,
  gbreve: xb,
  Gcedil: yb,
  Gcirc: Eb,
  gcirc: wb,
  Gcy: Ab,
  gcy: Cb,
  Gdot: Sb,
  gdot: Db,
  ge: Tb,
  gE: Rb,
  gEl: Lb,
  gel: Nb,
  geq: qb,
  geqq: Mb,
  geqslant: Ib,
  gescc: Ob,
  ges: Fb,
  gesdot: Bb,
  gesdoto: Pb,
  gesdotol: $b,
  gesl: zb,
  gesles: Ub,
  Gfr: Hb,
  gfr: Vb,
  gg: Gb,
  Gg: jb,
  ggg: Zb,
  gimel: Kb,
  GJcy: Wb,
  gjcy: Yb,
  gla: Jb,
  gl: Xb,
  glE: Qb,
  glj: e0,
  gnap: n0,
  gnapprox: t0,
  gne: r0,
  gnE: o0,
  gneq: s0,
  gneqq: c0,
  gnsim: i0,
  Gopf: a0,
  gopf: l0,
  grave: u0,
  GreaterEqual: f0,
  GreaterEqualLess: p0,
  GreaterFullEqual: h0,
  GreaterGreater: d0,
  GreaterLess: g0,
  GreaterSlantEqual: m0,
  GreaterTilde: _0,
  Gscr: b0,
  gscr: v0,
  gsim: k0,
  gsime: x0,
  gsiml: y0,
  gtcc: E0,
  gtcir: w0,
  gt: A0,
  GT: C0,
  Gt: S0,
  gtdot: D0,
  gtlPar: T0,
  gtquest: R0,
  gtrapprox: L0,
  gtrarr: N0,
  gtrdot: q0,
  gtreqless: M0,
  gtreqqless: I0,
  gtrless: O0,
  gtrsim: F0,
  gvertneqq: B0,
  gvnE: P0,
  Hacek: $0,
  hairsp: z0,
  half: U0,
  hamilt: H0,
  HARDcy: V0,
  hardcy: G0,
  harrcir: j0,
  harr: Z0,
  hArr: K0,
  harrw: W0,
  Hat: Y0,
  hbar: J0,
  Hcirc: X0,
  hcirc: Q0,
  hearts: ev,
  heartsuit: nv,
  hellip: tv,
  hercon: rv,
  hfr: ov,
  Hfr: sv,
  HilbertSpace: cv,
  hksearow: iv,
  hkswarow: av,
  hoarr: lv,
  homtht: uv,
  hookleftarrow: fv,
  hookrightarrow: pv,
  hopf: hv,
  Hopf: dv,
  horbar: gv,
  HorizontalLine: mv,
  hscr: _v,
  Hscr: bv,
  hslash: vv,
  Hstrok: kv,
  hstrok: xv,
  HumpDownHump: yv,
  HumpEqual: Ev,
  hybull: wv,
  hyphen: Av,
  Iacute: Cv,
  iacute: Sv,
  ic: Dv,
  Icirc: Tv,
  icirc: Rv,
  Icy: Lv,
  icy: Nv,
  Idot: qv,
  IEcy: Mv,
  iecy: Iv,
  iexcl: Ov,
  iff: Fv,
  ifr: Bv,
  Ifr: Pv,
  Igrave: $v,
  igrave: zv,
  ii: Uv,
  iiiint: Hv,
  iiint: Vv,
  iinfin: Gv,
  iiota: jv,
  IJlig: Zv,
  ijlig: Kv,
  Imacr: Wv,
  imacr: Yv,
  image: Jv,
  ImaginaryI: Xv,
  imagline: Qv,
  imagpart: ek,
  imath: nk,
  Im: tk,
  imof: rk,
  imped: ok,
  Implies: sk,
  incare: ck,
  in: "∈",
  infin: ik,
  infintie: ak,
  inodot: lk,
  intcal: uk,
  int: fk,
  Int: pk,
  integers: hk,
  Integral: dk,
  intercal: gk,
  Intersection: mk,
  intlarhk: _k,
  intprod: bk,
  InvisibleComma: vk,
  InvisibleTimes: kk,
  IOcy: xk,
  iocy: yk,
  Iogon: Ek,
  iogon: wk,
  Iopf: Ak,
  iopf: Ck,
  Iota: Sk,
  iota: Dk,
  iprod: Tk,
  iquest: Rk,
  iscr: Lk,
  Iscr: Nk,
  isin: qk,
  isindot: Mk,
  isinE: Ik,
  isins: Ok,
  isinsv: Fk,
  isinv: Bk,
  it: Pk,
  Itilde: $k,
  itilde: zk,
  Iukcy: Uk,
  iukcy: Hk,
  Iuml: Vk,
  iuml: Gk,
  Jcirc: jk,
  jcirc: Zk,
  Jcy: Kk,
  jcy: Wk,
  Jfr: Yk,
  jfr: Jk,
  jmath: Xk,
  Jopf: Qk,
  jopf: ex,
  Jscr: nx,
  jscr: tx,
  Jsercy: rx,
  jsercy: ox,
  Jukcy: sx,
  jukcy: cx,
  Kappa: ix,
  kappa: ax,
  kappav: lx,
  Kcedil: ux,
  kcedil: fx,
  Kcy: px,
  kcy: hx,
  Kfr: dx,
  kfr: gx,
  kgreen: mx,
  KHcy: _x,
  khcy: bx,
  KJcy: vx,
  kjcy: kx,
  Kopf: xx,
  kopf: yx,
  Kscr: Ex,
  kscr: wx,
  lAarr: Ax,
  Lacute: Cx,
  lacute: Sx,
  laemptyv: Dx,
  lagran: Tx,
  Lambda: Rx,
  lambda: Lx,
  lang: Nx,
  Lang: qx,
  langd: Mx,
  langle: Ix,
  lap: Ox,
  Laplacetrf: Fx,
  laquo: Bx,
  larrb: Px,
  larrbfs: $x,
  larr: zx,
  Larr: Ux,
  lArr: Hx,
  larrfs: Vx,
  larrhk: Gx,
  larrlp: jx,
  larrpl: Zx,
  larrsim: Kx,
  larrtl: Wx,
  latail: Yx,
  lAtail: Jx,
  lat: Xx,
  late: Qx,
  lates: ey,
  lbarr: ny,
  lBarr: ty,
  lbbrk: ry,
  lbrace: oy,
  lbrack: sy,
  lbrke: cy,
  lbrksld: iy,
  lbrkslu: ay,
  Lcaron: ly,
  lcaron: uy,
  Lcedil: fy,
  lcedil: py,
  lceil: hy,
  lcub: dy,
  Lcy: gy,
  lcy: my,
  ldca: _y,
  ldquo: by,
  ldquor: vy,
  ldrdhar: ky,
  ldrushar: xy,
  ldsh: yy,
  le: Ey,
  lE: wy,
  LeftAngleBracket: Ay,
  LeftArrowBar: Cy,
  leftarrow: Sy,
  LeftArrow: Dy,
  Leftarrow: Ty,
  LeftArrowRightArrow: Ry,
  leftarrowtail: Ly,
  LeftCeiling: Ny,
  LeftDoubleBracket: qy,
  LeftDownTeeVector: My,
  LeftDownVectorBar: Iy,
  LeftDownVector: Oy,
  LeftFloor: Fy,
  leftharpoondown: By,
  leftharpoonup: Py,
  leftleftarrows: $y,
  leftrightarrow: zy,
  LeftRightArrow: Uy,
  Leftrightarrow: Hy,
  leftrightarrows: Vy,
  leftrightharpoons: Gy,
  leftrightsquigarrow: jy,
  LeftRightVector: Zy,
  LeftTeeArrow: Ky,
  LeftTee: Wy,
  LeftTeeVector: Yy,
  leftthreetimes: Jy,
  LeftTriangleBar: Xy,
  LeftTriangle: Qy,
  LeftTriangleEqual: eE,
  LeftUpDownVector: nE,
  LeftUpTeeVector: tE,
  LeftUpVectorBar: rE,
  LeftUpVector: oE,
  LeftVectorBar: sE,
  LeftVector: cE,
  lEg: iE,
  leg: aE,
  leq: lE,
  leqq: uE,
  leqslant: fE,
  lescc: pE,
  les: hE,
  lesdot: dE,
  lesdoto: gE,
  lesdotor: mE,
  lesg: _E,
  lesges: bE,
  lessapprox: vE,
  lessdot: kE,
  lesseqgtr: xE,
  lesseqqgtr: yE,
  LessEqualGreater: EE,
  LessFullEqual: wE,
  LessGreater: AE,
  lessgtr: CE,
  LessLess: SE,
  lesssim: DE,
  LessSlantEqual: TE,
  LessTilde: RE,
  lfisht: LE,
  lfloor: NE,
  Lfr: qE,
  lfr: ME,
  lg: IE,
  lgE: OE,
  lHar: FE,
  lhard: BE,
  lharu: PE,
  lharul: $E,
  lhblk: zE,
  LJcy: UE,
  ljcy: HE,
  llarr: VE,
  ll: GE,
  Ll: jE,
  llcorner: ZE,
  Lleftarrow: KE,
  llhard: WE,
  lltri: YE,
  Lmidot: JE,
  lmidot: XE,
  lmoustache: QE,
  lmoust: ew,
  lnap: nw,
  lnapprox: tw,
  lne: rw,
  lnE: ow,
  lneq: sw,
  lneqq: cw,
  lnsim: iw,
  loang: aw,
  loarr: lw,
  lobrk: uw,
  longleftarrow: fw,
  LongLeftArrow: pw,
  Longleftarrow: hw,
  longleftrightarrow: dw,
  LongLeftRightArrow: gw,
  Longleftrightarrow: mw,
  longmapsto: _w,
  longrightarrow: bw,
  LongRightArrow: vw,
  Longrightarrow: kw,
  looparrowleft: xw,
  looparrowright: yw,
  lopar: Ew,
  Lopf: ww,
  lopf: Aw,
  loplus: Cw,
  lotimes: Sw,
  lowast: Dw,
  lowbar: Tw,
  LowerLeftArrow: Rw,
  LowerRightArrow: Lw,
  loz: Nw,
  lozenge: qw,
  lozf: Mw,
  lpar: Iw,
  lparlt: Ow,
  lrarr: Fw,
  lrcorner: Bw,
  lrhar: Pw,
  lrhard: $w,
  lrm: zw,
  lrtri: Uw,
  lsaquo: Hw,
  lscr: Vw,
  Lscr: Gw,
  lsh: jw,
  Lsh: Zw,
  lsim: Kw,
  lsime: Ww,
  lsimg: Yw,
  lsqb: Jw,
  lsquo: Xw,
  lsquor: Qw,
  Lstrok: e1,
  lstrok: n1,
  ltcc: t1,
  ltcir: r1,
  lt: o1,
  LT: s1,
  Lt: c1,
  ltdot: i1,
  lthree: a1,
  ltimes: l1,
  ltlarr: u1,
  ltquest: f1,
  ltri: p1,
  ltrie: h1,
  ltrif: d1,
  ltrPar: g1,
  lurdshar: m1,
  luruhar: _1,
  lvertneqq: b1,
  lvnE: v1,
  macr: k1,
  male: x1,
  malt: y1,
  maltese: E1,
  Map: "⤅",
  map: w1,
  mapsto: A1,
  mapstodown: C1,
  mapstoleft: S1,
  mapstoup: D1,
  marker: T1,
  mcomma: R1,
  Mcy: L1,
  mcy: N1,
  mdash: q1,
  mDDot: M1,
  measuredangle: I1,
  MediumSpace: O1,
  Mellintrf: F1,
  Mfr: B1,
  mfr: P1,
  mho: $1,
  micro: z1,
  midast: U1,
  midcir: H1,
  mid: V1,
  middot: G1,
  minusb: j1,
  minus: Z1,
  minusd: K1,
  minusdu: W1,
  MinusPlus: Y1,
  mlcp: J1,
  mldr: X1,
  mnplus: Q1,
  models: eA,
  Mopf: nA,
  mopf: tA,
  mp: rA,
  mscr: oA,
  Mscr: sA,
  mstpos: cA,
  Mu: iA,
  mu: aA,
  multimap: lA,
  mumap: uA,
  nabla: fA,
  Nacute: pA,
  nacute: hA,
  nang: dA,
  nap: gA,
  napE: mA,
  napid: _A,
  napos: bA,
  napprox: vA,
  natural: kA,
  naturals: xA,
  natur: yA,
  nbsp: EA,
  nbump: wA,
  nbumpe: AA,
  ncap: CA,
  Ncaron: SA,
  ncaron: DA,
  Ncedil: TA,
  ncedil: RA,
  ncong: LA,
  ncongdot: NA,
  ncup: qA,
  Ncy: MA,
  ncy: IA,
  ndash: OA,
  nearhk: FA,
  nearr: BA,
  neArr: PA,
  nearrow: $A,
  ne: zA,
  nedot: UA,
  NegativeMediumSpace: HA,
  NegativeThickSpace: VA,
  NegativeThinSpace: GA,
  NegativeVeryThinSpace: jA,
  nequiv: ZA,
  nesear: KA,
  nesim: WA,
  NestedGreaterGreater: YA,
  NestedLessLess: JA,
  NewLine: XA,
  nexist: QA,
  nexists: eC,
  Nfr: nC,
  nfr: tC,
  ngE: rC,
  nge: oC,
  ngeq: sC,
  ngeqq: cC,
  ngeqslant: iC,
  nges: aC,
  nGg: lC,
  ngsim: uC,
  nGt: fC,
  ngt: pC,
  ngtr: hC,
  nGtv: dC,
  nharr: gC,
  nhArr: mC,
  nhpar: _C,
  ni: bC,
  nis: vC,
  nisd: kC,
  niv: xC,
  NJcy: yC,
  njcy: EC,
  nlarr: wC,
  nlArr: AC,
  nldr: CC,
  nlE: SC,
  nle: DC,
  nleftarrow: TC,
  nLeftarrow: RC,
  nleftrightarrow: LC,
  nLeftrightarrow: NC,
  nleq: qC,
  nleqq: MC,
  nleqslant: IC,
  nles: OC,
  nless: FC,
  nLl: BC,
  nlsim: PC,
  nLt: $C,
  nlt: zC,
  nltri: UC,
  nltrie: HC,
  nLtv: VC,
  nmid: GC,
  NoBreak: jC,
  NonBreakingSpace: ZC,
  nopf: KC,
  Nopf: WC,
  Not: YC,
  not: JC,
  NotCongruent: XC,
  NotCupCap: QC,
  NotDoubleVerticalBar: eS,
  NotElement: nS,
  NotEqual: tS,
  NotEqualTilde: rS,
  NotExists: oS,
  NotGreater: sS,
  NotGreaterEqual: cS,
  NotGreaterFullEqual: iS,
  NotGreaterGreater: aS,
  NotGreaterLess: lS,
  NotGreaterSlantEqual: uS,
  NotGreaterTilde: fS,
  NotHumpDownHump: pS,
  NotHumpEqual: hS,
  notin: dS,
  notindot: gS,
  notinE: mS,
  notinva: _S,
  notinvb: bS,
  notinvc: vS,
  NotLeftTriangleBar: kS,
  NotLeftTriangle: xS,
  NotLeftTriangleEqual: yS,
  NotLess: ES,
  NotLessEqual: wS,
  NotLessGreater: AS,
  NotLessLess: CS,
  NotLessSlantEqual: SS,
  NotLessTilde: DS,
  NotNestedGreaterGreater: TS,
  NotNestedLessLess: RS,
  notni: LS,
  notniva: NS,
  notnivb: qS,
  notnivc: MS,
  NotPrecedes: IS,
  NotPrecedesEqual: OS,
  NotPrecedesSlantEqual: FS,
  NotReverseElement: BS,
  NotRightTriangleBar: PS,
  NotRightTriangle: $S,
  NotRightTriangleEqual: zS,
  NotSquareSubset: US,
  NotSquareSubsetEqual: HS,
  NotSquareSuperset: VS,
  NotSquareSupersetEqual: GS,
  NotSubset: jS,
  NotSubsetEqual: ZS,
  NotSucceeds: KS,
  NotSucceedsEqual: WS,
  NotSucceedsSlantEqual: YS,
  NotSucceedsTilde: JS,
  NotSuperset: XS,
  NotSupersetEqual: QS,
  NotTilde: eD,
  NotTildeEqual: nD,
  NotTildeFullEqual: tD,
  NotTildeTilde: rD,
  NotVerticalBar: oD,
  nparallel: sD,
  npar: cD,
  nparsl: iD,
  npart: aD,
  npolint: lD,
  npr: uD,
  nprcue: fD,
  nprec: pD,
  npreceq: hD,
  npre: dD,
  nrarrc: gD,
  nrarr: mD,
  nrArr: _D,
  nrarrw: bD,
  nrightarrow: vD,
  nRightarrow: kD,
  nrtri: xD,
  nrtrie: yD,
  nsc: ED,
  nsccue: wD,
  nsce: AD,
  Nscr: CD,
  nscr: SD,
  nshortmid: DD,
  nshortparallel: TD,
  nsim: RD,
  nsime: LD,
  nsimeq: ND,
  nsmid: qD,
  nspar: MD,
  nsqsube: ID,
  nsqsupe: OD,
  nsub: FD,
  nsubE: BD,
  nsube: PD,
  nsubset: $D,
  nsubseteq: zD,
  nsubseteqq: UD,
  nsucc: HD,
  nsucceq: VD,
  nsup: GD,
  nsupE: jD,
  nsupe: ZD,
  nsupset: KD,
  nsupseteq: WD,
  nsupseteqq: YD,
  ntgl: JD,
  Ntilde: XD,
  ntilde: QD,
  ntlg: eT,
  ntriangleleft: nT,
  ntrianglelefteq: tT,
  ntriangleright: rT,
  ntrianglerighteq: oT,
  Nu: sT,
  nu: cT,
  num: iT,
  numero: aT,
  numsp: lT,
  nvap: uT,
  nvdash: fT,
  nvDash: pT,
  nVdash: hT,
  nVDash: dT,
  nvge: gT,
  nvgt: mT,
  nvHarr: _T,
  nvinfin: bT,
  nvlArr: vT,
  nvle: kT,
  nvlt: xT,
  nvltrie: yT,
  nvrArr: ET,
  nvrtrie: wT,
  nvsim: AT,
  nwarhk: CT,
  nwarr: ST,
  nwArr: DT,
  nwarrow: TT,
  nwnear: RT,
  Oacute: LT,
  oacute: NT,
  oast: qT,
  Ocirc: MT,
  ocirc: IT,
  ocir: OT,
  Ocy: FT,
  ocy: BT,
  odash: PT,
  Odblac: $T,
  odblac: zT,
  odiv: UT,
  odot: HT,
  odsold: VT,
  OElig: GT,
  oelig: jT,
  ofcir: ZT,
  Ofr: KT,
  ofr: WT,
  ogon: YT,
  Ograve: JT,
  ograve: XT,
  ogt: QT,
  ohbar: eR,
  ohm: nR,
  oint: tR,
  olarr: rR,
  olcir: oR,
  olcross: sR,
  oline: cR,
  olt: iR,
  Omacr: aR,
  omacr: lR,
  Omega: uR,
  omega: fR,
  Omicron: pR,
  omicron: hR,
  omid: dR,
  ominus: gR,
  Oopf: mR,
  oopf: _R,
  opar: bR,
  OpenCurlyDoubleQuote: vR,
  OpenCurlyQuote: kR,
  operp: xR,
  oplus: yR,
  orarr: ER,
  Or: wR,
  or: AR,
  ord: CR,
  order: SR,
  orderof: DR,
  ordf: TR,
  ordm: RR,
  origof: LR,
  oror: NR,
  orslope: qR,
  orv: MR,
  oS: IR,
  Oscr: OR,
  oscr: FR,
  Oslash: BR,
  oslash: PR,
  osol: $R,
  Otilde: zR,
  otilde: UR,
  otimesas: HR,
  Otimes: VR,
  otimes: GR,
  Ouml: jR,
  ouml: ZR,
  ovbar: KR,
  OverBar: WR,
  OverBrace: YR,
  OverBracket: JR,
  OverParenthesis: XR,
  para: QR,
  parallel: e2,
  par: n2,
  parsim: t2,
  parsl: r2,
  part: o2,
  PartialD: s2,
  Pcy: c2,
  pcy: i2,
  percnt: a2,
  period: l2,
  permil: u2,
  perp: f2,
  pertenk: p2,
  Pfr: h2,
  pfr: d2,
  Phi: g2,
  phi: m2,
  phiv: _2,
  phmmat: b2,
  phone: v2,
  Pi: k2,
  pi: x2,
  pitchfork: y2,
  piv: E2,
  planck: w2,
  planckh: A2,
  plankv: C2,
  plusacir: S2,
  plusb: D2,
  pluscir: T2,
  plus: R2,
  plusdo: L2,
  plusdu: N2,
  pluse: q2,
  PlusMinus: M2,
  plusmn: I2,
  plussim: O2,
  plustwo: F2,
  pm: B2,
  Poincareplane: P2,
  pointint: $2,
  popf: z2,
  Popf: U2,
  pound: H2,
  prap: V2,
  Pr: G2,
  pr: j2,
  prcue: Z2,
  precapprox: K2,
  prec: W2,
  preccurlyeq: Y2,
  Precedes: J2,
  PrecedesEqual: X2,
  PrecedesSlantEqual: Q2,
  PrecedesTilde: eL,
  preceq: nL,
  precnapprox: tL,
  precneqq: rL,
  precnsim: oL,
  pre: sL,
  prE: cL,
  precsim: iL,
  prime: aL,
  Prime: lL,
  primes: uL,
  prnap: fL,
  prnE: pL,
  prnsim: hL,
  prod: dL,
  Product: gL,
  profalar: mL,
  profline: _L,
  profsurf: bL,
  prop: vL,
  Proportional: kL,
  Proportion: xL,
  propto: yL,
  prsim: EL,
  prurel: wL,
  Pscr: AL,
  pscr: CL,
  Psi: SL,
  psi: DL,
  puncsp: TL,
  Qfr: RL,
  qfr: LL,
  qint: NL,
  qopf: qL,
  Qopf: ML,
  qprime: IL,
  Qscr: OL,
  qscr: FL,
  quaternions: BL,
  quatint: PL,
  quest: $L,
  questeq: zL,
  quot: UL,
  QUOT: HL,
  rAarr: VL,
  race: GL,
  Racute: jL,
  racute: ZL,
  radic: KL,
  raemptyv: WL,
  rang: YL,
  Rang: JL,
  rangd: XL,
  range: QL,
  rangle: eN,
  raquo: nN,
  rarrap: tN,
  rarrb: rN,
  rarrbfs: oN,
  rarrc: sN,
  rarr: cN,
  Rarr: iN,
  rArr: aN,
  rarrfs: lN,
  rarrhk: uN,
  rarrlp: fN,
  rarrpl: pN,
  rarrsim: hN,
  Rarrtl: dN,
  rarrtl: gN,
  rarrw: mN,
  ratail: _N,
  rAtail: bN,
  ratio: vN,
  rationals: kN,
  rbarr: xN,
  rBarr: yN,
  RBarr: EN,
  rbbrk: wN,
  rbrace: AN,
  rbrack: CN,
  rbrke: SN,
  rbrksld: DN,
  rbrkslu: TN,
  Rcaron: RN,
  rcaron: LN,
  Rcedil: NN,
  rcedil: qN,
  rceil: MN,
  rcub: IN,
  Rcy: ON,
  rcy: FN,
  rdca: BN,
  rdldhar: PN,
  rdquo: $N,
  rdquor: zN,
  rdsh: UN,
  real: HN,
  realine: VN,
  realpart: GN,
  reals: jN,
  Re: ZN,
  rect: KN,
  reg: WN,
  REG: YN,
  ReverseElement: JN,
  ReverseEquilibrium: XN,
  ReverseUpEquilibrium: QN,
  rfisht: eq,
  rfloor: nq,
  rfr: tq,
  Rfr: rq,
  rHar: oq,
  rhard: sq,
  rharu: cq,
  rharul: iq,
  Rho: aq,
  rho: lq,
  rhov: uq,
  RightAngleBracket: fq,
  RightArrowBar: pq,
  rightarrow: hq,
  RightArrow: dq,
  Rightarrow: gq,
  RightArrowLeftArrow: mq,
  rightarrowtail: _q,
  RightCeiling: bq,
  RightDoubleBracket: vq,
  RightDownTeeVector: kq,
  RightDownVectorBar: xq,
  RightDownVector: yq,
  RightFloor: Eq,
  rightharpoondown: wq,
  rightharpoonup: Aq,
  rightleftarrows: Cq,
  rightleftharpoons: Sq,
  rightrightarrows: Dq,
  rightsquigarrow: Tq,
  RightTeeArrow: Rq,
  RightTee: Lq,
  RightTeeVector: Nq,
  rightthreetimes: qq,
  RightTriangleBar: Mq,
  RightTriangle: Iq,
  RightTriangleEqual: Oq,
  RightUpDownVector: Fq,
  RightUpTeeVector: Bq,
  RightUpVectorBar: Pq,
  RightUpVector: $q,
  RightVectorBar: zq,
  RightVector: Uq,
  ring: Hq,
  risingdotseq: Vq,
  rlarr: Gq,
  rlhar: jq,
  rlm: Zq,
  rmoustache: Kq,
  rmoust: Wq,
  rnmid: Yq,
  roang: Jq,
  roarr: Xq,
  robrk: Qq,
  ropar: eM,
  ropf: nM,
  Ropf: tM,
  roplus: rM,
  rotimes: oM,
  RoundImplies: sM,
  rpar: cM,
  rpargt: iM,
  rppolint: aM,
  rrarr: lM,
  Rrightarrow: uM,
  rsaquo: fM,
  rscr: pM,
  Rscr: hM,
  rsh: dM,
  Rsh: gM,
  rsqb: mM,
  rsquo: _M,
  rsquor: bM,
  rthree: vM,
  rtimes: kM,
  rtri: xM,
  rtrie: yM,
  rtrif: EM,
  rtriltri: wM,
  RuleDelayed: AM,
  ruluhar: CM,
  rx: SM,
  Sacute: DM,
  sacute: TM,
  sbquo: RM,
  scap: LM,
  Scaron: NM,
  scaron: qM,
  Sc: MM,
  sc: IM,
  sccue: OM,
  sce: FM,
  scE: BM,
  Scedil: PM,
  scedil: $M,
  Scirc: zM,
  scirc: UM,
  scnap: HM,
  scnE: VM,
  scnsim: GM,
  scpolint: jM,
  scsim: ZM,
  Scy: KM,
  scy: WM,
  sdotb: YM,
  sdot: JM,
  sdote: XM,
  searhk: QM,
  searr: eI,
  seArr: nI,
  searrow: tI,
  sect: rI,
  semi: oI,
  seswar: sI,
  setminus: cI,
  setmn: iI,
  sext: aI,
  Sfr: lI,
  sfr: uI,
  sfrown: fI,
  sharp: pI,
  SHCHcy: hI,
  shchcy: dI,
  SHcy: gI,
  shcy: mI,
  ShortDownArrow: _I,
  ShortLeftArrow: bI,
  shortmid: vI,
  shortparallel: kI,
  ShortRightArrow: xI,
  ShortUpArrow: yI,
  shy: EI,
  Sigma: wI,
  sigma: AI,
  sigmaf: CI,
  sigmav: SI,
  sim: DI,
  simdot: TI,
  sime: RI,
  simeq: LI,
  simg: NI,
  simgE: qI,
  siml: MI,
  simlE: II,
  simne: OI,
  simplus: FI,
  simrarr: BI,
  slarr: PI,
  SmallCircle: $I,
  smallsetminus: zI,
  smashp: UI,
  smeparsl: HI,
  smid: VI,
  smile: GI,
  smt: jI,
  smte: ZI,
  smtes: KI,
  SOFTcy: WI,
  softcy: YI,
  solbar: JI,
  solb: XI,
  sol: QI,
  Sopf: eO,
  sopf: nO,
  spades: tO,
  spadesuit: rO,
  spar: oO,
  sqcap: sO,
  sqcaps: cO,
  sqcup: iO,
  sqcups: aO,
  Sqrt: lO,
  sqsub: uO,
  sqsube: fO,
  sqsubset: pO,
  sqsubseteq: hO,
  sqsup: dO,
  sqsupe: gO,
  sqsupset: mO,
  sqsupseteq: _O,
  square: bO,
  Square: vO,
  SquareIntersection: kO,
  SquareSubset: xO,
  SquareSubsetEqual: yO,
  SquareSuperset: EO,
  SquareSupersetEqual: wO,
  SquareUnion: AO,
  squarf: CO,
  squ: SO,
  squf: DO,
  srarr: TO,
  Sscr: RO,
  sscr: LO,
  ssetmn: NO,
  ssmile: qO,
  sstarf: MO,
  Star: IO,
  star: OO,
  starf: FO,
  straightepsilon: BO,
  straightphi: PO,
  strns: $O,
  sub: zO,
  Sub: UO,
  subdot: HO,
  subE: VO,
  sube: GO,
  subedot: jO,
  submult: ZO,
  subnE: KO,
  subne: WO,
  subplus: YO,
  subrarr: JO,
  subset: XO,
  Subset: QO,
  subseteq: eF,
  subseteqq: nF,
  SubsetEqual: tF,
  subsetneq: rF,
  subsetneqq: oF,
  subsim: sF,
  subsub: cF,
  subsup: iF,
  succapprox: aF,
  succ: lF,
  succcurlyeq: uF,
  Succeeds: fF,
  SucceedsEqual: pF,
  SucceedsSlantEqual: hF,
  SucceedsTilde: dF,
  succeq: gF,
  succnapprox: mF,
  succneqq: _F,
  succnsim: bF,
  succsim: vF,
  SuchThat: kF,
  sum: xF,
  Sum: yF,
  sung: EF,
  sup1: wF,
  sup2: AF,
  sup3: CF,
  sup: SF,
  Sup: DF,
  supdot: TF,
  supdsub: RF,
  supE: LF,
  supe: NF,
  supedot: qF,
  Superset: MF,
  SupersetEqual: IF,
  suphsol: OF,
  suphsub: FF,
  suplarr: BF,
  supmult: PF,
  supnE: $F,
  supne: zF,
  supplus: UF,
  supset: HF,
  Supset: VF,
  supseteq: GF,
  supseteqq: jF,
  supsetneq: ZF,
  supsetneqq: KF,
  supsim: WF,
  supsub: YF,
  supsup: JF,
  swarhk: XF,
  swarr: QF,
  swArr: eB,
  swarrow: nB,
  swnwar: tB,
  szlig: rB,
  Tab: oB,
  target: sB,
  Tau: cB,
  tau: iB,
  tbrk: aB,
  Tcaron: lB,
  tcaron: uB,
  Tcedil: fB,
  tcedil: pB,
  Tcy: hB,
  tcy: dB,
  tdot: gB,
  telrec: mB,
  Tfr: _B,
  tfr: bB,
  there4: vB,
  therefore: kB,
  Therefore: xB,
  Theta: yB,
  theta: EB,
  thetasym: wB,
  thetav: AB,
  thickapprox: CB,
  thicksim: SB,
  ThickSpace: DB,
  ThinSpace: TB,
  thinsp: RB,
  thkap: LB,
  thksim: NB,
  THORN: qB,
  thorn: MB,
  tilde: IB,
  Tilde: OB,
  TildeEqual: FB,
  TildeFullEqual: BB,
  TildeTilde: PB,
  timesbar: $B,
  timesb: zB,
  times: UB,
  timesd: HB,
  tint: VB,
  toea: GB,
  topbot: jB,
  topcir: ZB,
  top: KB,
  Topf: WB,
  topf: YB,
  topfork: JB,
  tosa: XB,
  tprime: QB,
  trade: eP,
  TRADE: nP,
  triangle: tP,
  triangledown: rP,
  triangleleft: oP,
  trianglelefteq: sP,
  triangleq: cP,
  triangleright: iP,
  trianglerighteq: aP,
  tridot: lP,
  trie: uP,
  triminus: fP,
  TripleDot: pP,
  triplus: hP,
  trisb: dP,
  tritime: gP,
  trpezium: mP,
  Tscr: _P,
  tscr: bP,
  TScy: vP,
  tscy: kP,
  TSHcy: xP,
  tshcy: yP,
  Tstrok: EP,
  tstrok: wP,
  twixt: AP,
  twoheadleftarrow: CP,
  twoheadrightarrow: SP,
  Uacute: DP,
  uacute: TP,
  uarr: RP,
  Uarr: LP,
  uArr: NP,
  Uarrocir: qP,
  Ubrcy: MP,
  ubrcy: IP,
  Ubreve: OP,
  ubreve: FP,
  Ucirc: BP,
  ucirc: PP,
  Ucy: $P,
  ucy: zP,
  udarr: UP,
  Udblac: HP,
  udblac: VP,
  udhar: GP,
  ufisht: jP,
  Ufr: ZP,
  ufr: KP,
  Ugrave: WP,
  ugrave: YP,
  uHar: JP,
  uharl: XP,
  uharr: QP,
  uhblk: e$,
  ulcorn: n$,
  ulcorner: t$,
  ulcrop: r$,
  ultri: o$,
  Umacr: s$,
  umacr: c$,
  uml: i$,
  UnderBar: a$,
  UnderBrace: l$,
  UnderBracket: u$,
  UnderParenthesis: f$,
  Union: p$,
  UnionPlus: h$,
  Uogon: d$,
  uogon: g$,
  Uopf: m$,
  uopf: _$,
  UpArrowBar: b$,
  uparrow: v$,
  UpArrow: k$,
  Uparrow: x$,
  UpArrowDownArrow: y$,
  updownarrow: E$,
  UpDownArrow: w$,
  Updownarrow: A$,
  UpEquilibrium: C$,
  upharpoonleft: S$,
  upharpoonright: D$,
  uplus: T$,
  UpperLeftArrow: R$,
  UpperRightArrow: L$,
  upsi: N$,
  Upsi: q$,
  upsih: M$,
  Upsilon: I$,
  upsilon: O$,
  UpTeeArrow: F$,
  UpTee: B$,
  upuparrows: P$,
  urcorn: $$,
  urcorner: z$,
  urcrop: U$,
  Uring: H$,
  uring: V$,
  urtri: G$,
  Uscr: j$,
  uscr: Z$,
  utdot: K$,
  Utilde: W$,
  utilde: Y$,
  utri: J$,
  utrif: X$,
  uuarr: Q$,
  Uuml: ez,
  uuml: nz,
  uwangle: tz,
  vangrt: rz,
  varepsilon: oz,
  varkappa: sz,
  varnothing: cz,
  varphi: iz,
  varpi: az,
  varpropto: lz,
  varr: uz,
  vArr: fz,
  varrho: pz,
  varsigma: hz,
  varsubsetneq: dz,
  varsubsetneqq: gz,
  varsupsetneq: mz,
  varsupsetneqq: _z,
  vartheta: bz,
  vartriangleleft: vz,
  vartriangleright: kz,
  vBar: xz,
  Vbar: yz,
  vBarv: Ez,
  Vcy: wz,
  vcy: Az,
  vdash: Cz,
  vDash: Sz,
  Vdash: Dz,
  VDash: Tz,
  Vdashl: Rz,
  veebar: Lz,
  vee: Nz,
  Vee: qz,
  veeeq: Mz,
  vellip: Iz,
  verbar: Oz,
  Verbar: Fz,
  vert: Bz,
  Vert: Pz,
  VerticalBar: $z,
  VerticalLine: zz,
  VerticalSeparator: Uz,
  VerticalTilde: Hz,
  VeryThinSpace: Vz,
  Vfr: Gz,
  vfr: jz,
  vltri: Zz,
  vnsub: Kz,
  vnsup: Wz,
  Vopf: Yz,
  vopf: Jz,
  vprop: Xz,
  vrtri: Qz,
  Vscr: e3,
  vscr: n3,
  vsubnE: t3,
  vsubne: r3,
  vsupnE: o3,
  vsupne: s3,
  Vvdash: c3,
  vzigzag: i3,
  Wcirc: a3,
  wcirc: l3,
  wedbar: u3,
  wedge: f3,
  Wedge: p3,
  wedgeq: h3,
  weierp: d3,
  Wfr: g3,
  wfr: m3,
  Wopf: _3,
  wopf: b3,
  wp: v3,
  wr: k3,
  wreath: x3,
  Wscr: y3,
  wscr: E3,
  xcap: w3,
  xcirc: A3,
  xcup: C3,
  xdtri: S3,
  Xfr: D3,
  xfr: T3,
  xharr: R3,
  xhArr: L3,
  Xi: N3,
  xi: q3,
  xlarr: M3,
  xlArr: I3,
  xmap: O3,
  xnis: F3,
  xodot: B3,
  Xopf: P3,
  xopf: $3,
  xoplus: z3,
  xotime: U3,
  xrarr: H3,
  xrArr: V3,
  Xscr: G3,
  xscr: j3,
  xsqcup: Z3,
  xuplus: K3,
  xutri: W3,
  xvee: Y3,
  xwedge: J3,
  Yacute: X3,
  yacute: Q3,
  YAcy: eU,
  yacy: nU,
  Ycirc: tU,
  ycirc: rU,
  Ycy: oU,
  ycy: sU,
  yen: cU,
  Yfr: iU,
  yfr: aU,
  YIcy: lU,
  yicy: uU,
  Yopf: fU,
  yopf: pU,
  Yscr: hU,
  yscr: dU,
  YUcy: gU,
  yucy: mU,
  yuml: _U,
  Yuml: bU,
  Zacute: vU,
  zacute: kU,
  Zcaron: xU,
  zcaron: yU,
  Zcy: EU,
  zcy: wU,
  Zdot: AU,
  zdot: CU,
  zeetrf: SU,
  ZeroWidthSpace: DU,
  Zeta: TU,
  zeta: RU,
  zfr: LU,
  Zfr: NU,
  ZHcy: qU,
  zhcy: MU,
  zigrarr: IU,
  zopf: OU,
  Zopf: FU,
  Zscr: BU,
  zscr: PU,
  zwj: $U,
  zwnj: zU
};
var zr = UU;
var Jn = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var Me = {};
var wt = {};
function HU(n) {
  var e, t, r = wt[n];
  if (r)
    return r;
  for (r = wt[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), /^[0-9a-z]$/i.test(t) ? r.push(t) : r.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < n.length; e++)
    r[n.charCodeAt(e)] = n[e];
  return r;
}
function pn(n, e, t) {
  var r, o, s, i, c, a = "";
  for (typeof e != "string" && (t = e, e = pn.defaultChars), typeof t > "u" && (t = true), c = HU(e), r = 0, o = n.length; r < o; r++) {
    if (s = n.charCodeAt(r), t && s === 37 && r + 2 < o && /^[0-9a-f]{2}$/i.test(n.slice(r + 1, r + 3))) {
      a += n.slice(r, r + 3), r += 2;
      continue;
    }
    if (s < 128) {
      a += c[s];
      continue;
    }
    if (s >= 55296 && s <= 57343) {
      if (s >= 55296 && s <= 56319 && r + 1 < o && (i = n.charCodeAt(r + 1), i >= 56320 && i <= 57343)) {
        a += encodeURIComponent(n[r] + n[r + 1]), r++;
        continue;
      }
      a += "%EF%BF%BD";
      continue;
    }
    a += encodeURIComponent(n[r]);
  }
  return a;
}
pn.defaultChars = ";/?:@&=+$,-_.!~*'()#";
pn.componentChars = "-_.!~*'()";
var VU = pn;
var At = {};
function GU(n) {
  var e, t, r = At[n];
  if (r)
    return r;
  for (r = At[n] = [], e = 0; e < 128; e++)
    t = String.fromCharCode(e), r.push(t);
  for (e = 0; e < n.length; e++)
    t = n.charCodeAt(e), r[t] = "%" + ("0" + t.toString(16).toUpperCase()).slice(-2);
  return r;
}
function hn(n, e) {
  var t;
  return typeof e != "string" && (e = hn.defaultChars), t = GU(e), n.replace(/(%[a-f0-9]{2})+/gi, function(r) {
    var o, s, i, c, a, l, u, p = "";
    for (o = 0, s = r.length; o < s; o += 3) {
      if (i = parseInt(r.slice(o + 1, o + 3), 16), i < 128) {
        p += t[i];
        continue;
      }
      if ((i & 224) === 192 && o + 3 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), (c & 192) === 128)) {
        u = i << 6 & 1984 | c & 63, u < 128 ? p += "��" : p += String.fromCharCode(u), o += 3;
        continue;
      }
      if ((i & 240) === 224 && o + 6 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), (c & 192) === 128 && (a & 192) === 128)) {
        u = i << 12 & 61440 | c << 6 & 4032 | a & 63, u < 2048 || u >= 55296 && u <= 57343 ? p += "���" : p += String.fromCharCode(u), o += 6;
        continue;
      }
      if ((i & 248) === 240 && o + 9 < s && (c = parseInt(r.slice(o + 4, o + 6), 16), a = parseInt(r.slice(o + 7, o + 9), 16), l = parseInt(r.slice(o + 10, o + 12), 16), (c & 192) === 128 && (a & 192) === 128 && (l & 192) === 128)) {
        u = i << 18 & 1835008 | c << 12 & 258048 | a << 6 & 4032 | l & 63, u < 65536 || u > 1114111 ? p += "����" : (u -= 65536, p += String.fromCharCode(55296 + (u >> 10), 56320 + (u & 1023))), o += 9;
        continue;
      }
      p += "�";
    }
    return p;
  });
}
hn.defaultChars = ";/?:@&=+$,#";
hn.componentChars = "";
var jU = hn;
var ZU = function(e) {
  var t = "";
  return t += e.protocol || "", t += e.slashes ? "//" : "", t += e.auth ? e.auth + "@" : "", e.hostname && e.hostname.indexOf(":") !== -1 ? t += "[" + e.hostname + "]" : t += e.hostname || "", t += e.port ? ":" + e.port : "", t += e.pathname || "", t += e.search || "", t += e.hash || "", t;
};
function cn() {
  this.protocol = null, this.slashes = null, this.auth = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.pathname = null;
}
var KU = /^([a-z0-9.+-]+:)/i;
var WU = /:[0-9]*$/;
var YU = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var JU = ["<", ">", '"', "`", " ", "\r", `
`, "	"];
var XU = ["{", "}", "|", "\\", "^", "`"].concat(JU);
var QU = ["'"].concat(XU);
var Ct = ["%", "/", "?", ";", "#"].concat(QU);
var St = ["/", "?", "#"];
var e9 = 255;
var Dt = /^[+a-z0-9A-Z_-]{0,63}$/;
var n9 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var Tt = {
  javascript: true,
  "javascript:": true
};
var Rt = {
  http: true,
  https: true,
  ftp: true,
  gopher: true,
  file: true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function t9(n, e) {
  if (n && n instanceof cn)
    return n;
  var t = new cn();
  return t.parse(n, e), t;
}
cn.prototype.parse = function(n, e) {
  var t, r, o, s, i, c = n;
  if (c = c.trim(), !e && n.split("#").length === 1) {
    var a = YU.exec(c);
    if (a)
      return this.pathname = a[1], a[2] && (this.search = a[2]), this;
  }
  var l = KU.exec(c);
  if (l && (l = l[0], o = l.toLowerCase(), this.protocol = l, c = c.substr(l.length)), (e || l || c.match(/^\/\/[^@\/]+@[^@\/]+/)) && (i = c.substr(0, 2) === "//", i && !(l && Tt[l]) && (c = c.substr(2), this.slashes = true)), !Tt[l] && (i || l && !Rt[l])) {
    var u = -1;
    for (t = 0; t < St.length; t++)
      s = c.indexOf(St[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    var p, f;
    for (u === -1 ? f = c.lastIndexOf("@") : f = c.lastIndexOf("@", u), f !== -1 && (p = c.slice(0, f), c = c.slice(f + 1), this.auth = p), u = -1, t = 0; t < Ct.length; t++)
      s = c.indexOf(Ct[t]), s !== -1 && (u === -1 || s < u) && (u = s);
    u === -1 && (u = c.length), c[u - 1] === ":" && u--;
    var h5 = c.slice(0, u);
    c = c.slice(u), this.parseHost(h5), this.hostname = this.hostname || "";
    var d = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!d) {
      var g = this.hostname.split(/\./);
      for (t = 0, r = g.length; t < r; t++) {
        var E = g[t];
        if (E && !E.match(Dt)) {
          for (var x = "", b = 0, A = E.length; b < A; b++)
            E.charCodeAt(b) > 127 ? x += "x" : x += E[b];
          if (!x.match(Dt)) {
            var D = g.slice(0, t), L = g.slice(t + 1), v = E.match(n9);
            v && (D.push(v[1]), L.unshift(v[2])), L.length && (c = L.join(".") + c), this.hostname = D.join(".");
            break;
          }
        }
      }
    }
    this.hostname.length > e9 && (this.hostname = ""), d && (this.hostname = this.hostname.substr(1, this.hostname.length - 2));
  }
  var O = c.indexOf("#");
  O !== -1 && (this.hash = c.substr(O), c = c.slice(0, O));
  var z = c.indexOf("?");
  return z !== -1 && (this.search = c.substr(z), c = c.slice(0, z)), c && (this.pathname = c), Rt[o] && this.hostname && !this.pathname && (this.pathname = ""), this;
};
cn.prototype.parseHost = function(n) {
  var e = WU.exec(n);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), n = n.substr(0, n.length - e.length)), n && (this.hostname = n);
};
var r9 = t9;
Me.encode = VU;
Me.decode = jU;
Me.format = ZU;
Me.parse = r9;
var Ee = {};
var Cn;
var Lt;
function Ur() {
  return Lt || (Lt = 1, Cn = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/), Cn;
}
var Sn;
var Nt;
function Hr() {
  return Nt || (Nt = 1, Sn = /[\0-\x1F\x7F-\x9F]/), Sn;
}
var Dn;
var qt;
function o9() {
  return qt || (qt = 1, Dn = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/), Dn;
}
var Tn;
var Mt;
function Vr() {
  return Mt || (Mt = 1, Tn = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/), Tn;
}
var It;
function s9() {
  return It || (It = 1, Ee.Any = Ur(), Ee.Cc = Hr(), Ee.Cf = o9(), Ee.P = Jn, Ee.Z = Vr()), Ee;
}
(function(n) {
  function e(_) {
    return Object.prototype.toString.call(_);
  }
  function t(_) {
    return e(_) === "[object String]";
  }
  var r = Object.prototype.hasOwnProperty;
  function o(_, T) {
    return r.call(_, T);
  }
  function s(_) {
    var T = Array.prototype.slice.call(arguments, 1);
    return T.forEach(function(w) {
      if (w) {
        if (typeof w != "object")
          throw new TypeError(w + "must be object");
        Object.keys(w).forEach(function(m) {
          _[m] = w[m];
        });
      }
    }), _;
  }
  function i(_, T, w) {
    return [].concat(_.slice(0, T), w, _.slice(T + 1));
  }
  function c(_) {
    return !(_ >= 55296 && _ <= 57343 || _ >= 64976 && _ <= 65007 || (_ & 65535) === 65535 || (_ & 65535) === 65534 || _ >= 0 && _ <= 8 || _ === 11 || _ >= 14 && _ <= 31 || _ >= 127 && _ <= 159 || _ > 1114111);
  }
  function a(_) {
    if (_ > 65535) {
      _ -= 65536;
      var T = 55296 + (_ >> 10), w = 56320 + (_ & 1023);
      return String.fromCharCode(T, w);
    }
    return String.fromCharCode(_);
  }
  var l = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g, u = /&([a-z#][a-z0-9]{1,31});/gi, p = new RegExp(l.source + "|" + u.source, "gi"), f = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i, h5 = zr;
  function d(_, T) {
    var w;
    return o(h5, T) ? h5[T] : T.charCodeAt(0) === 35 && f.test(T) && (w = T[1].toLowerCase() === "x" ? parseInt(T.slice(2), 16) : parseInt(T.slice(1), 10), c(w)) ? a(w) : _;
  }
  function g(_) {
    return _.indexOf("\\") < 0 ? _ : _.replace(l, "$1");
  }
  function E(_) {
    return _.indexOf("\\") < 0 && _.indexOf("&") < 0 ? _ : _.replace(p, function(T, w, m) {
      return w || d(T, m);
    });
  }
  var x = /[&<>"]/, b = /[&<>"]/g, A = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function D(_) {
    return A[_];
  }
  function L(_) {
    return x.test(_) ? _.replace(b, D) : _;
  }
  var v = /[.?*+^$[\]\\(){}|-]/g;
  function O(_) {
    return _.replace(v, "\\$&");
  }
  function z(_) {
    switch (_) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function j(_) {
    if (_ >= 8192 && _ <= 8202)
      return true;
    switch (_) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var M = Jn;
  function K(_) {
    return M.test(_);
  }
  function q(_) {
    switch (_) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function Z(_) {
    return _ = _.trim().replace(/\s+/g, " "), "ẞ".toLowerCase() === "Ṿ" && (_ = _.replace(/ẞ/g, "ß")), _.toLowerCase().toUpperCase();
  }
  n.lib = {}, n.lib.mdurl = Me, n.lib.ucmicro = s9(), n.assign = s, n.isString = t, n.has = o, n.unescapeMd = g, n.unescapeAll = E, n.isValidEntityCode = c, n.fromCodePoint = a, n.escapeHtml = L, n.arrayReplaceAt = i, n.isSpace = z, n.isWhiteSpace = j, n.isMdAsciiPunct = q, n.isPunctChar = K, n.escapeRE = O, n.normalizeReference = Z;
})($);
var dn = {};
var c9 = function(e, t, r) {
  var o, s, i, c, a = -1, l = e.posMax, u = e.pos;
  for (e.pos = t + 1, o = 1; e.pos < l; ) {
    if (i = e.src.charCodeAt(e.pos), i === 93 && (o--, o === 0)) {
      s = true;
      break;
    }
    if (c = e.pos, e.md.inline.skipToken(e), i === 91) {
      if (c === e.pos - 1)
        o++;
      else if (r)
        return e.pos = u, -1;
    }
  }
  return s && (a = e.pos), e.pos = u, a;
};
var Ot = $.unescapeAll;
var i9 = function(e, t, r) {
  var o, s, i = t, c = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (e.charCodeAt(i) === 60) {
    for (i++; i < r; ) {
      if (o = e.charCodeAt(i), o === 10 || o === 60)
        return c;
      if (o === 62)
        return c.pos = i + 1, c.str = Ot(e.slice(t + 1, i)), c.ok = true, c;
      if (o === 92 && i + 1 < r) {
        i += 2;
        continue;
      }
      i++;
    }
    return c;
  }
  for (s = 0; i < r && (o = e.charCodeAt(i), !(o === 32 || o < 32 || o === 127)); ) {
    if (o === 92 && i + 1 < r) {
      if (e.charCodeAt(i + 1) === 32)
        break;
      i += 2;
      continue;
    }
    if (o === 40 && (s++, s > 32))
      return c;
    if (o === 41) {
      if (s === 0)
        break;
      s--;
    }
    i++;
  }
  return t === i || s !== 0 || (c.str = Ot(e.slice(t, i)), c.pos = i, c.ok = true), c;
};
var a9 = $.unescapeAll;
var l9 = function(e, t, r) {
  var o, s, i = 0, c = t, a = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (c >= r || (s = e.charCodeAt(c), s !== 34 && s !== 39 && s !== 40))
    return a;
  for (c++, s === 40 && (s = 41); c < r; ) {
    if (o = e.charCodeAt(c), o === s)
      return a.pos = c + 1, a.lines = i, a.str = a9(e.slice(t + 1, c)), a.ok = true, a;
    if (o === 40 && s === 41)
      return a;
    o === 10 ? i++ : o === 92 && c + 1 < r && (c++, e.charCodeAt(c) === 10 && i++), c++;
  }
  return a;
};
dn.parseLinkLabel = c9;
dn.parseLinkDestination = i9;
dn.parseLinkTitle = l9;
var u9 = $.assign;
var f9 = $.unescapeAll;
var Se = $.escapeHtml;
var ge = {};
ge.code_inline = function(n, e, t, r, o) {
  var s = n[e];
  return "<code" + o.renderAttrs(s) + ">" + Se(s.content) + "</code>";
};
ge.code_block = function(n, e, t, r, o) {
  var s = n[e];
  return "<pre" + o.renderAttrs(s) + "><code>" + Se(n[e].content) + `</code></pre>
`;
};
ge.fence = function(n, e, t, r, o) {
  var s = n[e], i = s.info ? f9(s.info).trim() : "", c = "", a = "", l, u, p, f, h5;
  return i && (p = i.split(/(\s+)/g), c = p[0], a = p.slice(2).join("")), t.highlight ? l = t.highlight(s.content, c, a) || Se(s.content) : l = Se(s.content), l.indexOf("<pre") === 0 ? l + `
` : i ? (u = s.attrIndex("class"), f = s.attrs ? s.attrs.slice() : [], u < 0 ? f.push(["class", t.langPrefix + c]) : (f[u] = f[u].slice(), f[u][1] += " " + t.langPrefix + c), h5 = {
    attrs: f
  }, "<pre><code" + o.renderAttrs(h5) + ">" + l + `</code></pre>
`) : "<pre><code" + o.renderAttrs(s) + ">" + l + `</code></pre>
`;
};
ge.image = function(n, e, t, r, o) {
  var s = n[e];
  return s.attrs[s.attrIndex("alt")][1] = o.renderInlineAsText(s.children, t, r), o.renderToken(n, e, t);
};
ge.hardbreak = function(n, e, t) {
  return t.xhtmlOut ? `<br />
` : `<br>
`;
};
ge.softbreak = function(n, e, t) {
  return t.breaks ? t.xhtmlOut ? `<br />
` : `<br>
` : `
`;
};
ge.text = function(n, e) {
  return Se(n[e].content);
};
ge.html_block = function(n, e) {
  return n[e].content;
};
ge.html_inline = function(n, e) {
  return n[e].content;
};
function Ie() {
  this.rules = u9({}, ge);
}
Ie.prototype.renderAttrs = function(e) {
  var t, r, o;
  if (!e.attrs)
    return "";
  for (o = "", t = 0, r = e.attrs.length; t < r; t++)
    o += " " + Se(e.attrs[t][0]) + '="' + Se(e.attrs[t][1]) + '"';
  return o;
};
Ie.prototype.renderToken = function(e, t, r) {
  var o, s = "", i = false, c = e[t];
  return c.hidden ? "" : (c.block && c.nesting !== -1 && t && e[t - 1].hidden && (s += `
`), s += (c.nesting === -1 ? "</" : "<") + c.tag, s += this.renderAttrs(c), c.nesting === 0 && r.xhtmlOut && (s += " /"), c.block && (i = true, c.nesting === 1 && t + 1 < e.length && (o = e[t + 1], (o.type === "inline" || o.hidden || o.nesting === -1 && o.tag === c.tag) && (i = false))), s += i ? `>
` : ">", s);
};
Ie.prototype.renderInline = function(n, e, t) {
  for (var r, o = "", s = this.rules, i = 0, c = n.length; i < c; i++)
    r = n[i].type, typeof s[r] < "u" ? o += s[r](n, i, e, t, this) : o += this.renderToken(n, i, e);
  return o;
};
Ie.prototype.renderInlineAsText = function(n, e, t) {
  for (var r = "", o = 0, s = n.length; o < s; o++)
    n[o].type === "text" ? r += n[o].content : n[o].type === "image" ? r += this.renderInlineAsText(n[o].children, e, t) : n[o].type === "softbreak" && (r += `
`);
  return r;
};
Ie.prototype.render = function(n, e, t) {
  var r, o, s, i = "", c = this.rules;
  for (r = 0, o = n.length; r < o; r++)
    s = n[r].type, s === "inline" ? i += this.renderInline(n[r].children, e, t) : typeof c[s] < "u" ? i += c[s](n, r, e, t, this) : i += this.renderToken(n, r, e, t);
  return i;
};
var p9 = Ie;
function le() {
  this.__rules__ = [], this.__cache__ = null;
}
le.prototype.__find__ = function(n) {
  for (var e = 0; e < this.__rules__.length; e++)
    if (this.__rules__[e].name === n)
      return e;
  return -1;
};
le.prototype.__compile__ = function() {
  var n = this, e = [""];
  n.__rules__.forEach(function(t) {
    t.enabled && t.alt.forEach(function(r) {
      e.indexOf(r) < 0 && e.push(r);
    });
  }), n.__cache__ = {}, e.forEach(function(t) {
    n.__cache__[t] = [], n.__rules__.forEach(function(r) {
      r.enabled && (t && r.alt.indexOf(t) < 0 || n.__cache__[t].push(r.fn));
    });
  });
};
le.prototype.at = function(n, e, t) {
  var r = this.__find__(n), o = t || {};
  if (r === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__[r].fn = e, this.__rules__[r].alt = o.alt || [], this.__cache__ = null;
};
le.prototype.before = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o, 0, {
    name: e,
    enabled: true,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.after = function(n, e, t, r) {
  var o = this.__find__(n), s = r || {};
  if (o === -1)
    throw new Error("Parser rule not found: " + n);
  this.__rules__.splice(o + 1, 0, {
    name: e,
    enabled: true,
    fn: t,
    alt: s.alt || []
  }), this.__cache__ = null;
};
le.prototype.push = function(n, e, t) {
  var r = t || {};
  this.__rules__.push({
    name: n,
    enabled: true,
    fn: e,
    alt: r.alt || []
  }), this.__cache__ = null;
};
le.prototype.enable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = true, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.enableOnly = function(n, e) {
  Array.isArray(n) || (n = [n]), this.__rules__.forEach(function(t) {
    t.enabled = false;
  }), this.enable(n, e);
};
le.prototype.disable = function(n, e) {
  Array.isArray(n) || (n = [n]);
  var t = [];
  return n.forEach(function(r) {
    var o = this.__find__(r);
    if (o < 0) {
      if (e)
        return;
      throw new Error("Rules manager: invalid rule name " + r);
    }
    this.__rules__[o].enabled = false, t.push(r);
  }, this), this.__cache__ = null, t;
};
le.prototype.getRules = function(n) {
  return this.__cache__ === null && this.__compile__(), this.__cache__[n] || [];
};
var Xn = le;
var h9 = /\r\n?|\n/g;
var d9 = /\0/g;
var g9 = function(e) {
  var t;
  t = e.src.replace(h9, `
`), t = t.replace(d9, "�"), e.src = t;
};
var m9 = function(e) {
  var t;
  e.inlineMode ? (t = new e.Token("inline", "", 0), t.content = e.src, t.map = [0, 1], t.children = [], e.tokens.push(t)) : e.md.block.parse(e.src, e.md, e.env, e.tokens);
};
var _9 = function(e) {
  var t = e.tokens, r, o, s;
  for (o = 0, s = t.length; o < s; o++)
    r = t[o], r.type === "inline" && e.md.inline.parse(r.content, e.md, e.env, r.children);
};
var b9 = $.arrayReplaceAt;
function v9(n) {
  return /^<a[>\s]/i.test(n);
}
function k9(n) {
  return /^<\/a\s*>/i.test(n);
}
var x9 = function(e) {
  var t, r, o, s, i, c, a, l, u, p, f, h5, d, g, E, x, b = e.tokens, A;
  if (e.md.options.linkify) {
    for (r = 0, o = b.length; r < o; r++)
      if (!(b[r].type !== "inline" || !e.md.linkify.pretest(b[r].content)))
        for (s = b[r].children, d = 0, t = s.length - 1; t >= 0; t--) {
          if (c = s[t], c.type === "link_close") {
            for (t--; s[t].level !== c.level && s[t].type !== "link_open"; )
              t--;
            continue;
          }
          if (c.type === "html_inline" && (v9(c.content) && d > 0 && d--, k9(c.content) && d++), !(d > 0) && c.type === "text" && e.md.linkify.test(c.content)) {
            for (u = c.content, A = e.md.linkify.match(u), a = [], h5 = c.level, f = 0, A.length > 0 && A[0].index === 0 && t > 0 && s[t - 1].type === "text_special" && (A = A.slice(1)), l = 0; l < A.length; l++)
              g = A[l].url, E = e.md.normalizeLink(g), e.md.validateLink(E) && (x = A[l].text, A[l].schema ? A[l].schema === "mailto:" && !/^mailto:/i.test(x) ? x = e.md.normalizeLinkText("mailto:" + x).replace(/^mailto:/, "") : x = e.md.normalizeLinkText(x) : x = e.md.normalizeLinkText("http://" + x).replace(/^http:\/\//, ""), p = A[l].index, p > f && (i = new e.Token("text", "", 0), i.content = u.slice(f, p), i.level = h5, a.push(i)), i = new e.Token("link_open", "a", 1), i.attrs = [["href", E]], i.level = h5++, i.markup = "linkify", i.info = "auto", a.push(i), i = new e.Token("text", "", 0), i.content = x, i.level = h5, a.push(i), i = new e.Token("link_close", "a", -1), i.level = --h5, i.markup = "linkify", i.info = "auto", a.push(i), f = A[l].lastIndex);
            f < u.length && (i = new e.Token("text", "", 0), i.content = u.slice(f), i.level = h5, a.push(i)), b[r].children = s = b9(s, t, a);
          }
        }
  }
};
var Gr = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var y9 = /\((c|tm|r)\)/i;
var E9 = /\((c|tm|r)\)/ig;
var w9 = {
  c: "©",
  r: "®",
  tm: "™"
};
function A9(n, e) {
  return w9[e.toLowerCase()];
}
function C9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && (t.content = t.content.replace(E9, A9)), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
function S9(n) {
  var e, t, r = 0;
  for (e = n.length - 1; e >= 0; e--)
    t = n[e], t.type === "text" && !r && Gr.test(t.content) && (t.content = t.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–")), t.type === "link_open" && t.info === "auto" && r--, t.type === "link_close" && t.info === "auto" && r++;
}
var D9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type === "inline" && (y9.test(e.tokens[t].content) && C9(e.tokens[t].children), Gr.test(e.tokens[t].content) && S9(e.tokens[t].children));
};
var Ft = $.isWhiteSpace;
var Bt = $.isPunctChar;
var Pt = $.isMdAsciiPunct;
var T9 = /['"]/;
var $t = /['"]/g;
var zt = "’";
function Qe(n, e, t) {
  return n.slice(0, e) + t + n.slice(e + 1);
}
function R9(n, e) {
  var t, r, o, s, i, c, a, l, u, p, f, h5, d, g, E, x, b, A, D, L, v;
  for (D = [], t = 0; t < n.length; t++) {
    for (r = n[t], a = n[t].level, b = D.length - 1; b >= 0 && !(D[b].level <= a); b--)
      ;
    if (D.length = b + 1, r.type === "text") {
      o = r.content, i = 0, c = o.length;
      e:
        for (; i < c && ($t.lastIndex = i, s = $t.exec(o), !!s); ) {
          if (E = x = true, i = s.index + 1, A = s[0] === "'", u = 32, s.index - 1 >= 0)
            u = o.charCodeAt(s.index - 1);
          else
            for (b = t - 1; b >= 0 && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b--)
              if (n[b].content) {
                u = n[b].content.charCodeAt(n[b].content.length - 1);
                break;
              }
          if (p = 32, i < c)
            p = o.charCodeAt(i);
          else
            for (b = t + 1; b < n.length && !(n[b].type === "softbreak" || n[b].type === "hardbreak"); b++)
              if (n[b].content) {
                p = n[b].content.charCodeAt(0);
                break;
              }
          if (f = Pt(u) || Bt(String.fromCharCode(u)), h5 = Pt(p) || Bt(String.fromCharCode(p)), d = Ft(u), g = Ft(p), g ? E = false : h5 && (d || f || (E = false)), d ? x = false : f && (g || h5 || (x = false)), p === 34 && s[0] === '"' && u >= 48 && u <= 57 && (x = E = false), E && x && (E = f, x = h5), !E && !x) {
            A && (r.content = Qe(r.content, s.index, zt));
            continue;
          }
          if (x) {
            for (b = D.length - 1; b >= 0 && (l = D[b], !(D[b].level < a)); b--)
              if (l.single === A && D[b].level === a) {
                l = D[b], A ? (L = e.md.options.quotes[2], v = e.md.options.quotes[3]) : (L = e.md.options.quotes[0], v = e.md.options.quotes[1]), r.content = Qe(r.content, s.index, v), n[l.token].content = Qe(
                  n[l.token].content,
                  l.pos,
                  L
                ), i += v.length - 1, l.token === t && (i += L.length - 1), o = r.content, c = o.length, D.length = b;
                continue e;
              }
          }
          E ? D.push({
            token: t,
            pos: s.index,
            single: A,
            level: a
          }) : x && A && (r.content = Qe(r.content, s.index, zt));
        }
    }
  }
}
var L9 = function(e) {
  var t;
  if (e.md.options.typographer)
    for (t = e.tokens.length - 1; t >= 0; t--)
      e.tokens[t].type !== "inline" || !T9.test(e.tokens[t].content) || R9(e.tokens[t].children, e);
};
var N9 = function(e) {
  var t, r, o, s, i, c, a = e.tokens;
  for (t = 0, r = a.length; t < r; t++)
    if (a[t].type === "inline") {
      for (o = a[t].children, i = o.length, s = 0; s < i; s++)
        o[s].type === "text_special" && (o[s].type = "text");
      for (s = c = 0; s < i; s++)
        o[s].type === "text" && s + 1 < i && o[s + 1].type === "text" ? o[s + 1].content = o[s].content + o[s + 1].content : (s !== c && (o[c] = o[s]), c++);
      s !== c && (o.length = c);
    }
};
function Oe(n, e, t) {
  this.type = n, this.tag = e, this.attrs = null, this.map = null, this.nesting = t, this.level = 0, this.children = null, this.content = "", this.markup = "", this.info = "", this.meta = null, this.block = false, this.hidden = false;
}
Oe.prototype.attrIndex = function(e) {
  var t, r, o;
  if (!this.attrs)
    return -1;
  for (t = this.attrs, r = 0, o = t.length; r < o; r++)
    if (t[r][0] === e)
      return r;
  return -1;
};
Oe.prototype.attrPush = function(e) {
  this.attrs ? this.attrs.push(e) : this.attrs = [e];
};
Oe.prototype.attrSet = function(e, t) {
  var r = this.attrIndex(e), o = [e, t];
  r < 0 ? this.attrPush(o) : this.attrs[r] = o;
};
Oe.prototype.attrGet = function(e) {
  var t = this.attrIndex(e), r = null;
  return t >= 0 && (r = this.attrs[t][1]), r;
};
Oe.prototype.attrJoin = function(e, t) {
  var r = this.attrIndex(e);
  r < 0 ? this.attrPush([e, t]) : this.attrs[r][1] = this.attrs[r][1] + " " + t;
};
var Qn = Oe;
var q9 = Qn;
function jr(n, e, t) {
  this.src = n, this.env = t, this.tokens = [], this.inlineMode = false, this.md = e;
}
jr.prototype.Token = q9;
var M9 = jr;
var I9 = Xn;
var Rn = [
  ["normalize", g9],
  ["block", m9],
  ["inline", _9],
  ["linkify", x9],
  ["replacements", D9],
  ["smartquotes", L9],
  // `text_join` finds `text_special` tokens (for escape sequences)
  // and joins them with the rest of the text
  ["text_join", N9]
];
function et() {
  this.ruler = new I9();
  for (var n = 0; n < Rn.length; n++)
    this.ruler.push(Rn[n][0], Rn[n][1]);
}
et.prototype.process = function(n) {
  var e, t, r;
  for (r = this.ruler.getRules(""), e = 0, t = r.length; e < t; e++)
    r[e](n);
};
et.prototype.State = M9;
var O9 = et;
var Ln = $.isSpace;
function Nn(n, e) {
  var t = n.bMarks[e] + n.tShift[e], r = n.eMarks[e];
  return n.src.slice(t, r);
}
function Ut(n) {
  var e = [], t = 0, r = n.length, o, s = false, i = 0, c = "";
  for (o = n.charCodeAt(t); t < r; )
    o === 124 && (s ? (c += n.substring(i, t - 1), i = t) : (e.push(c + n.substring(i, t)), c = "", i = t + 1)), s = o === 92, t++, o = n.charCodeAt(t);
  return e.push(c + n.substring(i)), e;
}
var F9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h5, d, g, E, x, b, A, D, L, v;
  if (t + 2 > r || (u = t + 1, e.sCount[u] < e.blkIndent) || e.sCount[u] - e.blkIndent >= 4 || (c = e.bMarks[u] + e.tShift[u], c >= e.eMarks[u]) || (L = e.src.charCodeAt(c++), L !== 124 && L !== 45 && L !== 58) || c >= e.eMarks[u] || (v = e.src.charCodeAt(c++), v !== 124 && v !== 45 && v !== 58 && !Ln(v)) || L === 45 && Ln(v))
    return false;
  for (; c < e.eMarks[u]; ) {
    if (s = e.src.charCodeAt(c), s !== 124 && s !== 45 && s !== 58 && !Ln(s))
      return false;
    c++;
  }
  for (i = Nn(e, t + 1), p = i.split("|"), d = [], a = 0; a < p.length; a++) {
    if (g = p[a].trim(), !g) {
      if (a === 0 || a === p.length - 1)
        continue;
      return false;
    }
    if (!/^:?-+:?$/.test(g))
      return false;
    g.charCodeAt(g.length - 1) === 58 ? d.push(g.charCodeAt(0) === 58 ? "center" : "right") : g.charCodeAt(0) === 58 ? d.push("left") : d.push("");
  }
  if (i = Nn(e, t).trim(), i.indexOf("|") === -1 || e.sCount[t] - e.blkIndent >= 4 || (p = Ut(i), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), f = p.length, f === 0 || f !== d.length))
    return false;
  if (o)
    return true;
  for (b = e.parentType, e.parentType = "table", D = e.md.block.ruler.getRules("blockquote"), h5 = e.push("table_open", "table", 1), h5.map = E = [t, 0], h5 = e.push("thead_open", "thead", 1), h5.map = [t, t + 1], h5 = e.push("tr_open", "tr", 1), h5.map = [t, t + 1], a = 0; a < p.length; a++)
    h5 = e.push("th_open", "th", 1), d[a] && (h5.attrs = [["style", "text-align:" + d[a]]]), h5 = e.push("inline", "", 0), h5.content = p[a].trim(), h5.children = [], h5 = e.push("th_close", "th", -1);
  for (h5 = e.push("tr_close", "tr", -1), h5 = e.push("thead_close", "thead", -1), u = t + 2; u < r && !(e.sCount[u] < e.blkIndent); u++) {
    for (A = false, a = 0, l = D.length; a < l; a++)
      if (D[a](e, u, r, true)) {
        A = true;
        break;
      }
    if (A || (i = Nn(e, u).trim(), !i) || e.sCount[u] - e.blkIndent >= 4)
      break;
    for (p = Ut(i), p.length && p[0] === "" && p.shift(), p.length && p[p.length - 1] === "" && p.pop(), u === t + 2 && (h5 = e.push("tbody_open", "tbody", 1), h5.map = x = [t + 2, 0]), h5 = e.push("tr_open", "tr", 1), h5.map = [u, u + 1], a = 0; a < f; a++)
      h5 = e.push("td_open", "td", 1), d[a] && (h5.attrs = [["style", "text-align:" + d[a]]]), h5 = e.push("inline", "", 0), h5.content = p[a] ? p[a].trim() : "", h5.children = [], h5 = e.push("td_close", "td", -1);
    h5 = e.push("tr_close", "tr", -1);
  }
  return x && (h5 = e.push("tbody_close", "tbody", -1), x[1] = u), h5 = e.push("table_close", "table", -1), E[1] = u, e.parentType = b, e.line = u, true;
};
var B9 = function(e, t, r) {
  var o, s, i;
  if (e.sCount[t] - e.blkIndent < 4)
    return false;
  for (s = o = t + 1; o < r; ) {
    if (e.isEmpty(o)) {
      o++;
      continue;
    }
    if (e.sCount[o] - e.blkIndent >= 4) {
      o++, s = o;
      continue;
    }
    break;
  }
  return e.line = s, i = e.push("code_block", "code", 0), i.content = e.getLines(t, s, 4 + e.blkIndent, false) + `
`, i.map = [t, e.line], true;
};
var P9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f = false, h5 = e.bMarks[t] + e.tShift[t], d = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || h5 + 3 > d || (s = e.src.charCodeAt(h5), s !== 126 && s !== 96) || (l = h5, h5 = e.skipChars(h5, s), i = h5 - l, i < 3) || (p = e.src.slice(l, h5), c = e.src.slice(h5, d), s === 96 && c.indexOf(String.fromCharCode(s)) >= 0))
    return false;
  if (o)
    return true;
  for (a = t; a++, !(a >= r || (h5 = l = e.bMarks[a] + e.tShift[a], d = e.eMarks[a], h5 < d && e.sCount[a] < e.blkIndent)); )
    if (e.src.charCodeAt(h5) === s && !(e.sCount[a] - e.blkIndent >= 4) && (h5 = e.skipChars(h5, s), !(h5 - l < i) && (h5 = e.skipSpaces(h5), !(h5 < d)))) {
      f = true;
      break;
    }
  return i = e.sCount[t], e.line = a + (f ? 1 : 0), u = e.push("fence", "code", 0), u.info = c, u.content = e.getLines(t + 1, a, i, true), u.markup = p, u.map = [t, e.line], true;
};
var $9 = $.isSpace;
var z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h5, d, g, E, x, b, A, D, L, v, O, z, j = e.lineMax, M = e.bMarks[t] + e.tShift[t], K = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(M) !== 62)
    return false;
  if (o)
    return true;
  for (d = [], g = [], b = [], A = [], v = e.md.block.ruler.getRules("blockquote"), x = e.parentType, e.parentType = "blockquote", f = t; f < r && (z = e.sCount[f] < e.blkIndent, M = e.bMarks[f] + e.tShift[f], K = e.eMarks[f], !(M >= K)); f++) {
    if (e.src.charCodeAt(M++) === 62 && !z) {
      for (a = e.sCount[f] + 1, e.src.charCodeAt(M) === 32 ? (M++, a++, s = false, D = true) : e.src.charCodeAt(M) === 9 ? (D = true, (e.bsCount[f] + a) % 4 === 3 ? (M++, a++, s = false) : s = true) : D = false, h5 = a, d.push(e.bMarks[f]), e.bMarks[f] = M; M < K && (i = e.src.charCodeAt(M), $9(i)); ) {
        i === 9 ? h5 += 4 - (h5 + e.bsCount[f] + (s ? 1 : 0)) % 4 : h5++;
        M++;
      }
      u = M >= K, g.push(e.bsCount[f]), e.bsCount[f] = e.sCount[f] + 1 + (D ? 1 : 0), b.push(e.sCount[f]), e.sCount[f] = h5 - a, A.push(e.tShift[f]), e.tShift[f] = M - e.bMarks[f];
      continue;
    }
    if (u)
      break;
    for (L = false, c = 0, l = v.length; c < l; c++)
      if (v[c](e, f, r, true)) {
        L = true;
        break;
      }
    if (L) {
      e.lineMax = f, e.blkIndent !== 0 && (d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] -= e.blkIndent);
      break;
    }
    d.push(e.bMarks[f]), g.push(e.bsCount[f]), A.push(e.tShift[f]), b.push(e.sCount[f]), e.sCount[f] = -1;
  }
  for (E = e.blkIndent, e.blkIndent = 0, O = e.push("blockquote_open", "blockquote", 1), O.markup = ">", O.map = p = [t, 0], e.md.block.tokenize(e, t, f), O = e.push("blockquote_close", "blockquote", -1), O.markup = ">", e.lineMax = j, e.parentType = x, p[1] = e.line, c = 0; c < A.length; c++)
    e.bMarks[c + t] = d[c], e.tShift[c + t] = A[c], e.sCount[c + t] = b[c], e.bsCount[c + t] = g[c];
  return e.blkIndent = E, true;
};
var U9 = $.isSpace;
var H9 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l++), s !== 42 && s !== 45 && s !== 95))
    return false;
  for (i = 1; l < u; ) {
    if (c = e.src.charCodeAt(l++), c !== s && !U9(c))
      return false;
    c === s && i++;
  }
  return i < 3 ? false : (o || (e.line = t + 1, a = e.push("hr", "hr", 0), a.map = [t, e.line], a.markup = Array(i + 1).join(String.fromCharCode(s))), true);
};
var Zr = $.isSpace;
function Ht(n, e) {
  var t, r, o, s;
  return r = n.bMarks[e] + n.tShift[e], o = n.eMarks[e], t = n.src.charCodeAt(r++), t !== 42 && t !== 45 && t !== 43 || r < o && (s = n.src.charCodeAt(r), !Zr(s)) ? -1 : r;
}
function Vt(n, e) {
  var t, r = n.bMarks[e] + n.tShift[e], o = r, s = n.eMarks[e];
  if (o + 1 >= s || (t = n.src.charCodeAt(o++), t < 48 || t > 57))
    return -1;
  for (; ; ) {
    if (o >= s)
      return -1;
    if (t = n.src.charCodeAt(o++), t >= 48 && t <= 57) {
      if (o - r >= 10)
        return -1;
      continue;
    }
    if (t === 41 || t === 46)
      break;
    return -1;
  }
  return o < s && (t = n.src.charCodeAt(o), !Zr(t)) ? -1 : o;
}
function V9(n, e) {
  var t, r, o = n.level + 2;
  for (t = e + 2, r = n.tokens.length - 2; t < r; t++)
    n.tokens[t].level === o && n.tokens[t].type === "paragraph_open" && (n.tokens[t + 2].hidden = true, n.tokens[t].hidden = true, t += 2);
}
var G9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h5, d, g, E, x, b, A, D, L, v, O, z, j, M, K, q, Z, _, T, w = t, m = false, k = true;
  if (e.sCount[w] - e.blkIndent >= 4 || e.listIndent >= 0 && e.sCount[w] - e.listIndent >= 4 && e.sCount[w] < e.blkIndent)
    return false;
  if (o && e.parentType === "paragraph" && e.sCount[w] >= e.blkIndent && (m = true), (M = Vt(e, w)) >= 0) {
    if (p = true, q = e.bMarks[w] + e.tShift[w], x = Number(e.src.slice(q, M - 1)), m && x !== 1)
      return false;
  } else if ((M = Ht(e, w)) >= 0)
    p = false;
  else
    return false;
  if (m && e.skipSpaces(M) >= e.eMarks[w])
    return false;
  if (o)
    return true;
  for (E = e.src.charCodeAt(M - 1), g = e.tokens.length, p ? (T = e.push("ordered_list_open", "ol", 1), x !== 1 && (T.attrs = [["start", x]])) : T = e.push("bullet_list_open", "ul", 1), T.map = d = [w, 0], T.markup = String.fromCharCode(E), K = false, _ = e.md.block.ruler.getRules("list"), L = e.parentType, e.parentType = "list"; w < r; ) {
    for (j = M, b = e.eMarks[w], u = A = e.sCount[w] + M - (e.bMarks[w] + e.tShift[w]); j < b; ) {
      if (s = e.src.charCodeAt(j), s === 9)
        A += 4 - (A + e.bsCount[w]) % 4;
      else if (s === 32)
        A++;
      else
        break;
      j++;
    }
    if (i = j, i >= b ? l = 1 : l = A - u, l > 4 && (l = 1), a = u + l, T = e.push("list_item_open", "li", 1), T.markup = String.fromCharCode(E), T.map = f = [w, 0], p && (T.info = e.src.slice(q, M - 1)), z = e.tight, O = e.tShift[w], v = e.sCount[w], D = e.listIndent, e.listIndent = e.blkIndent, e.blkIndent = a, e.tight = true, e.tShift[w] = i - e.bMarks[w], e.sCount[w] = A, i >= b && e.isEmpty(w + 1) ? e.line = Math.min(e.line + 2, r) : e.md.block.tokenize(e, w, r, true), (!e.tight || K) && (k = false), K = e.line - w > 1 && e.isEmpty(e.line - 1), e.blkIndent = e.listIndent, e.listIndent = D, e.tShift[w] = O, e.sCount[w] = v, e.tight = z, T = e.push("list_item_close", "li", -1), T.markup = String.fromCharCode(E), w = e.line, f[1] = w, w >= r || e.sCount[w] < e.blkIndent || e.sCount[w] - e.blkIndent >= 4)
      break;
    for (Z = false, c = 0, h5 = _.length; c < h5; c++)
      if (_[c](e, w, r, true)) {
        Z = true;
        break;
      }
    if (Z)
      break;
    if (p) {
      if (M = Vt(e, w), M < 0)
        break;
      q = e.bMarks[w] + e.tShift[w];
    } else if (M = Ht(e, w), M < 0)
      break;
    if (E !== e.src.charCodeAt(M - 1))
      break;
  }
  return p ? T = e.push("ordered_list_close", "ol", -1) : T = e.push("bullet_list_close", "ul", -1), T.markup = String.fromCharCode(E), d[1] = w, e.line = w, e.parentType = L, k && V9(e, g), true;
};
var j9 = $.normalizeReference;
var en = $.isSpace;
var Z9 = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f, h5, d, g, E, x, b, A, D, L = 0, v = e.bMarks[t] + e.tShift[t], O = e.eMarks[t], z = t + 1;
  if (e.sCount[t] - e.blkIndent >= 4 || e.src.charCodeAt(v) !== 91)
    return false;
  for (; ++v < O; )
    if (e.src.charCodeAt(v) === 93 && e.src.charCodeAt(v - 1) !== 92) {
      if (v + 1 === O || e.src.charCodeAt(v + 1) !== 58)
        return false;
      break;
    }
  for (a = e.lineMax, A = e.md.block.ruler.getRules("reference"), d = e.parentType, e.parentType = "reference"; z < a && !e.isEmpty(z); z++)
    if (!(e.sCount[z] - e.blkIndent > 3) && !(e.sCount[z] < 0)) {
      for (b = false, u = 0, p = A.length; u < p; u++)
        if (A[u](e, z, a, true)) {
          b = true;
          break;
        }
      if (b)
        break;
    }
  for (x = e.getLines(t, z, e.blkIndent, false).trim(), O = x.length, v = 1; v < O; v++) {
    if (s = x.charCodeAt(v), s === 91)
      return false;
    if (s === 93) {
      h5 = v;
      break;
    } else
      s === 10 ? L++ : s === 92 && (v++, v < O && x.charCodeAt(v) === 10 && L++);
  }
  if (h5 < 0 || x.charCodeAt(h5 + 1) !== 58)
    return false;
  for (v = h5 + 2; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  if (g = e.md.helpers.parseLinkDestination(x, v, O), !g.ok || (l = e.md.normalizeLink(g.str), !e.md.validateLink(l)))
    return false;
  for (v = g.pos, L += g.lines, i = v, c = L, E = v; v < O; v++)
    if (s = x.charCodeAt(v), s === 10)
      L++;
    else if (!en(s))
      break;
  for (g = e.md.helpers.parseLinkTitle(x, v, O), v < O && E !== v && g.ok ? (D = g.str, v = g.pos, L += g.lines) : (D = "", v = i, L = c); v < O && (s = x.charCodeAt(v), !!en(s)); )
    v++;
  if (v < O && x.charCodeAt(v) !== 10 && D)
    for (D = "", v = i, L = c; v < O && (s = x.charCodeAt(v), !!en(s)); )
      v++;
  return v < O && x.charCodeAt(v) !== 10 || (f = j9(x.slice(1, h5)), !f) ? false : (o || (typeof e.env.references > "u" && (e.env.references = {}), typeof e.env.references[f] > "u" && (e.env.references[f] = { title: D, href: l }), e.parentType = d, e.line = t + L + 1), true);
};
var K9 = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var gn = {};
var W9 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var Y9 = "[^\"'=<>`\\x00-\\x20]+";
var J9 = "'[^']*'";
var X9 = '"[^"]*"';
var Q9 = "(?:" + Y9 + "|" + J9 + "|" + X9 + ")";
var e4 = "(?:\\s+" + W9 + "(?:\\s*=\\s*" + Q9 + ")?)";
var Kr = "<[A-Za-z][A-Za-z0-9\\-]*" + e4 + "*\\s*\\/?>";
var Wr = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var n4 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var t4 = "<[?][\\s\\S]*?[?]>";
var r4 = "<![A-Z]+\\s+[^>]*>";
var o4 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var s4 = new RegExp("^(?:" + Kr + "|" + Wr + "|" + n4 + "|" + t4 + "|" + r4 + "|" + o4 + ")");
var c4 = new RegExp("^(?:" + Kr + "|" + Wr + ")");
gn.HTML_TAG_RE = s4;
gn.HTML_OPEN_CLOSE_TAG_RE = c4;
var i4 = K9;
var a4 = gn.HTML_OPEN_CLOSE_TAG_RE;
var Re = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + i4.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(a4.source + "\\s*$"), /^$/, false]
];
var l4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || !e.md.options.html || e.src.charCodeAt(l) !== 60)
    return false;
  for (a = e.src.slice(l, u), s = 0; s < Re.length && !Re[s][0].test(a); s++)
    ;
  if (s === Re.length)
    return false;
  if (o)
    return Re[s][2];
  if (i = t + 1, !Re[s][1].test(a)) {
    for (; i < r && !(e.sCount[i] < e.blkIndent); i++)
      if (l = e.bMarks[i] + e.tShift[i], u = e.eMarks[i], a = e.src.slice(l, u), Re[s][1].test(a)) {
        a.length !== 0 && i++;
        break;
      }
  }
  return e.line = i, c = e.push("html_block", "", 0), c.map = [t, i], c.content = e.getLines(t, i, e.blkIndent, true), true;
};
var Gt = $.isSpace;
var u4 = function(e, t, r, o) {
  var s, i, c, a, l = e.bMarks[t] + e.tShift[t], u = e.eMarks[t];
  if (e.sCount[t] - e.blkIndent >= 4 || (s = e.src.charCodeAt(l), s !== 35 || l >= u))
    return false;
  for (i = 1, s = e.src.charCodeAt(++l); s === 35 && l < u && i <= 6; )
    i++, s = e.src.charCodeAt(++l);
  return i > 6 || l < u && !Gt(s) ? false : (o || (u = e.skipSpacesBack(u, l), c = e.skipCharsBack(u, 35, l), c > l && Gt(e.src.charCodeAt(c - 1)) && (u = c), e.line = t + 1, a = e.push("heading_open", "h" + String(i), 1), a.markup = "########".slice(0, i), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = e.src.slice(l, u).trim(), a.map = [t, e.line], a.children = [], a = e.push("heading_close", "h" + String(i), -1), a.markup = "########".slice(0, i)), true);
};
var f4 = function(e, t, r) {
  var o, s, i, c, a, l, u, p, f, h5 = t + 1, d, g = e.md.block.ruler.getRules("paragraph");
  if (e.sCount[t] - e.blkIndent >= 4)
    return false;
  for (d = e.parentType, e.parentType = "paragraph"; h5 < r && !e.isEmpty(h5); h5++)
    if (!(e.sCount[h5] - e.blkIndent > 3)) {
      if (e.sCount[h5] >= e.blkIndent && (l = e.bMarks[h5] + e.tShift[h5], u = e.eMarks[h5], l < u && (f = e.src.charCodeAt(l), (f === 45 || f === 61) && (l = e.skipChars(l, f), l = e.skipSpaces(l), l >= u)))) {
        p = f === 61 ? 1 : 2;
        break;
      }
      if (!(e.sCount[h5] < 0)) {
        for (s = false, i = 0, c = g.length; i < c; i++)
          if (g[i](e, h5, r, true)) {
            s = true;
            break;
          }
        if (s)
          break;
      }
    }
  return p ? (o = e.getLines(t, h5, e.blkIndent, false).trim(), e.line = h5 + 1, a = e.push("heading_open", "h" + String(p), 1), a.markup = String.fromCharCode(f), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line - 1], a.children = [], a = e.push("heading_close", "h" + String(p), -1), a.markup = String.fromCharCode(f), e.parentType = d, true) : false;
};
var p4 = function(e, t, r) {
  var o, s, i, c, a, l, u = t + 1, p = e.md.block.ruler.getRules("paragraph");
  for (l = e.parentType, e.parentType = "paragraph"; u < r && !e.isEmpty(u); u++)
    if (!(e.sCount[u] - e.blkIndent > 3) && !(e.sCount[u] < 0)) {
      for (s = false, i = 0, c = p.length; i < c; i++)
        if (p[i](e, u, r, true)) {
          s = true;
          break;
        }
      if (s)
        break;
    }
  return o = e.getLines(t, u, e.blkIndent, false).trim(), e.line = u, a = e.push("paragraph_open", "p", 1), a.map = [t, e.line], a = e.push("inline", "", 0), a.content = o, a.map = [t, e.line], a.children = [], a = e.push("paragraph_close", "p", -1), e.parentType = l, true;
};
var Yr = Qn;
var mn = $.isSpace;
function me(n, e, t, r) {
  var o, s, i, c, a, l, u, p;
  for (this.src = n, this.md = e, this.env = t, this.tokens = r, this.bMarks = [], this.eMarks = [], this.tShift = [], this.sCount = [], this.bsCount = [], this.blkIndent = 0, this.line = 0, this.lineMax = 0, this.tight = false, this.ddIndent = -1, this.listIndent = -1, this.parentType = "root", this.level = 0, this.result = "", s = this.src, p = false, i = c = l = u = 0, a = s.length; c < a; c++) {
    if (o = s.charCodeAt(c), !p)
      if (mn(o)) {
        l++, o === 9 ? u += 4 - u % 4 : u++;
        continue;
      } else
        p = true;
    (o === 10 || c === a - 1) && (o !== 10 && c++, this.bMarks.push(i), this.eMarks.push(c), this.tShift.push(l), this.sCount.push(u), this.bsCount.push(0), p = false, l = 0, u = 0, i = c + 1);
  }
  this.bMarks.push(s.length), this.eMarks.push(s.length), this.tShift.push(0), this.sCount.push(0), this.bsCount.push(0), this.lineMax = this.bMarks.length - 1;
}
me.prototype.push = function(n, e, t) {
  var r = new Yr(n, e, t);
  return r.block = true, t < 0 && this.level--, r.level = this.level, t > 0 && this.level++, this.tokens.push(r), r;
};
me.prototype.isEmpty = function(e) {
  return this.bMarks[e] + this.tShift[e] >= this.eMarks[e];
};
me.prototype.skipEmptyLines = function(e) {
  for (var t = this.lineMax; e < t && !(this.bMarks[e] + this.tShift[e] < this.eMarks[e]); e++)
    ;
  return e;
};
me.prototype.skipSpaces = function(e) {
  for (var t, r = this.src.length; e < r && (t = this.src.charCodeAt(e), !!mn(t)); e++)
    ;
  return e;
};
me.prototype.skipSpacesBack = function(e, t) {
  if (e <= t)
    return e;
  for (; e > t; )
    if (!mn(this.src.charCodeAt(--e)))
      return e + 1;
  return e;
};
me.prototype.skipChars = function(e, t) {
  for (var r = this.src.length; e < r && this.src.charCodeAt(e) === t; e++)
    ;
  return e;
};
me.prototype.skipCharsBack = function(e, t, r) {
  if (e <= r)
    return e;
  for (; e > r; )
    if (t !== this.src.charCodeAt(--e))
      return e + 1;
  return e;
};
me.prototype.getLines = function(e, t, r, o) {
  var s, i, c, a, l, u, p, f = e;
  if (e >= t)
    return "";
  for (u = new Array(t - e), s = 0; f < t; f++, s++) {
    for (i = 0, p = a = this.bMarks[f], f + 1 < t || o ? l = this.eMarks[f] + 1 : l = this.eMarks[f]; a < l && i < r; ) {
      if (c = this.src.charCodeAt(a), mn(c))
        c === 9 ? i += 4 - (i + this.bsCount[f]) % 4 : i++;
      else if (a - p < this.tShift[f])
        i++;
      else
        break;
      a++;
    }
    i > r ? u[s] = new Array(i - r + 1).join(" ") + this.src.slice(a, l) : u[s] = this.src.slice(a, l);
  }
  return u.join("");
};
me.prototype.Token = Yr;
var h4 = me;
var d4 = Xn;
var nn = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  ["table", F9, ["paragraph", "reference"]],
  ["code", B9],
  ["fence", P9, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", z9, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", H9, ["paragraph", "reference", "blockquote", "list"]],
  ["list", G9, ["paragraph", "reference", "blockquote"]],
  ["reference", Z9],
  ["html_block", l4, ["paragraph", "reference", "blockquote"]],
  ["heading", u4, ["paragraph", "reference", "blockquote"]],
  ["lheading", f4],
  ["paragraph", p4]
];
function _n() {
  this.ruler = new d4();
  for (var n = 0; n < nn.length; n++)
    this.ruler.push(nn[n][0], nn[n][1], { alt: (nn[n][2] || []).slice() });
}
_n.prototype.tokenize = function(n, e, t) {
  for (var r, o, s, i = this.ruler.getRules(""), c = i.length, a = e, l = false, u = n.md.options.maxNesting; a < t && (n.line = a = n.skipEmptyLines(a), !(a >= t || n.sCount[a] < n.blkIndent)); ) {
    if (n.level >= u) {
      n.line = t;
      break;
    }
    for (s = n.line, o = 0; o < c; o++)
      if (r = i[o](n, a, t, false), r) {
        if (s >= n.line)
          throw new Error("block rule didn't increment state.line");
        break;
      }
    if (!r)
      throw new Error("none of the block rules matched");
    n.tight = !l, n.isEmpty(n.line - 1) && (l = true), a = n.line, a < t && n.isEmpty(a) && (l = true, a++, n.line = a);
  }
};
_n.prototype.parse = function(n, e, t, r) {
  var o;
  n && (o = new this.State(n, e, t, r), this.tokenize(o, o.line, o.lineMax));
};
_n.prototype.State = h4;
var g4 = _n;
function m4(n) {
  switch (n) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var _4 = function(e, t) {
  for (var r = e.pos; r < e.posMax && !m4(e.src.charCodeAt(r)); )
    r++;
  return r === e.pos ? false : (t || (e.pending += e.src.slice(e.pos, r)), e.pos = r, true);
};
var b4 = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
var v4 = function(e, t) {
  var r, o, s, i, c, a, l, u;
  return !e.md.options.linkify || e.linkLevel > 0 || (r = e.pos, o = e.posMax, r + 3 > o) || e.src.charCodeAt(r) !== 58 || e.src.charCodeAt(r + 1) !== 47 || e.src.charCodeAt(r + 2) !== 47 || (s = e.pending.match(b4), !s) || (i = s[1], c = e.md.linkify.matchAtStart(e.src.slice(r - i.length)), !c) || (a = c.url, a.length <= i.length) || (a = a.replace(/\*+$/, ""), l = e.md.normalizeLink(a), !e.md.validateLink(l)) ? false : (t || (e.pending = e.pending.slice(0, -i.length), u = e.push("link_open", "a", 1), u.attrs = [["href", l]], u.markup = "linkify", u.info = "auto", u = e.push("text", "", 0), u.content = e.md.normalizeLinkText(a), u = e.push("link_close", "a", -1), u.markup = "linkify", u.info = "auto"), e.pos += a.length - i.length, true);
};
var k4 = $.isSpace;
var x4 = function(e, t) {
  var r, o, s, i = e.pos;
  if (e.src.charCodeAt(i) !== 10)
    return false;
  if (r = e.pending.length - 1, o = e.posMax, !t)
    if (r >= 0 && e.pending.charCodeAt(r) === 32)
      if (r >= 1 && e.pending.charCodeAt(r - 1) === 32) {
        for (s = r - 1; s >= 1 && e.pending.charCodeAt(s - 1) === 32; )
          s--;
        e.pending = e.pending.slice(0, s), e.push("hardbreak", "br", 0);
      } else
        e.pending = e.pending.slice(0, -1), e.push("softbreak", "br", 0);
    else
      e.push("softbreak", "br", 0);
  for (i++; i < o && k4(e.src.charCodeAt(i)); )
    i++;
  return e.pos = i, true;
};
var y4 = $.isSpace;
var nt = [];
for (jt = 0; jt < 256; jt++)
  nt.push(0);
var jt;
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(n) {
  nt[n.charCodeAt(0)] = 1;
});
var E4 = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.posMax;
  if (e.src.charCodeAt(a) !== 92 || (a++, a >= l))
    return false;
  if (r = e.src.charCodeAt(a), r === 10) {
    for (t || e.push("hardbreak", "br", 0), a++; a < l && (r = e.src.charCodeAt(a), !!y4(r)); )
      a++;
    return e.pos = a, true;
  }
  return i = e.src[a], r >= 55296 && r <= 56319 && a + 1 < l && (o = e.src.charCodeAt(a + 1), o >= 56320 && o <= 57343 && (i += e.src[a + 1], a++)), s = "\\" + i, t || (c = e.push("text_special", "", 0), r < 256 && nt[r] !== 0 ? c.content = i : c.content = s, c.markup = s, c.info = "escape"), e.pos = a + 1, true;
};
var w4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p = e.pos, f = e.src.charCodeAt(p);
  if (f !== 96)
    return false;
  for (r = p, p++, o = e.posMax; p < o && e.src.charCodeAt(p) === 96; )
    p++;
  if (s = e.src.slice(r, p), l = s.length, e.backticksScanned && (e.backticks[l] || 0) <= r)
    return t || (e.pending += s), e.pos += l, true;
  for (a = p; (c = e.src.indexOf("`", a)) !== -1; ) {
    for (a = c + 1; a < o && e.src.charCodeAt(a) === 96; )
      a++;
    if (u = a - c, u === l)
      return t || (i = e.push("code_inline", "code", 0), i.markup = s, i.content = e.src.slice(p, c).replace(/\n/g, " ").replace(/^ (.+) $/, "$1")), e.pos = a, true;
    e.backticks[u] = c;
  }
  return e.backticksScanned = true, t || (e.pending += s), e.pos += l, true;
};
var bn = {};
bn.tokenize = function(e, t) {
  var r, o, s, i, c, a = e.pos, l = e.src.charCodeAt(a);
  if (t || l !== 126 || (o = e.scanDelims(e.pos, true), i = o.length, c = String.fromCharCode(l), i < 2))
    return false;
  for (i % 2 && (s = e.push("text", "", 0), s.content = c, i--), r = 0; r < i; r += 2)
    s = e.push("text", "", 0), s.content = c + c, e.delimiters.push({
      marker: l,
      length: 0,
      // disable "rule of 3" length checks meant for emphasis
      token: e.tokens.length - 1,
      end: -1,
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, true;
};
function Zt(n, e) {
  var t, r, o, s, i, c = [], a = e.length;
  for (t = 0; t < a; t++)
    o = e[t], o.marker === 126 && o.end !== -1 && (s = e[o.end], i = n.tokens[o.token], i.type = "s_open", i.tag = "s", i.nesting = 1, i.markup = "~~", i.content = "", i = n.tokens[s.token], i.type = "s_close", i.tag = "s", i.nesting = -1, i.markup = "~~", i.content = "", n.tokens[s.token - 1].type === "text" && n.tokens[s.token - 1].content === "~" && c.push(s.token - 1));
  for (; c.length; ) {
    for (t = c.pop(), r = t + 1; r < n.tokens.length && n.tokens[r].type === "s_close"; )
      r++;
    r--, t !== r && (i = n.tokens[r], n.tokens[r] = n.tokens[t], n.tokens[t] = i);
  }
}
bn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Zt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Zt(e, r[t].delimiters);
};
var vn = {};
vn.tokenize = function(e, t) {
  var r, o, s, i = e.pos, c = e.src.charCodeAt(i);
  if (t || c !== 95 && c !== 42)
    return false;
  for (o = e.scanDelims(e.pos, c === 42), r = 0; r < o.length; r++)
    s = e.push("text", "", 0), s.content = String.fromCharCode(c), e.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: c,
      // Total length of these series of delimiters.
      //
      length: o.length,
      // A position of the token this delimiter corresponds to.
      //
      token: e.tokens.length - 1,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: o.can_open,
      close: o.can_close
    });
  return e.pos += o.length, true;
};
function Kt(n, e) {
  var t, r, o, s, i, c, a = e.length;
  for (t = a - 1; t >= 0; t--)
    r = e[t], !(r.marker !== 95 && r.marker !== 42) && r.end !== -1 && (o = e[r.end], c = t > 0 && e[t - 1].end === r.end + 1 && // check that first two markers match and adjacent
    e[t - 1].marker === r.marker && e[t - 1].token === r.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
    e[r.end + 1].token === o.token + 1, i = String.fromCharCode(r.marker), s = n.tokens[r.token], s.type = c ? "strong_open" : "em_open", s.tag = c ? "strong" : "em", s.nesting = 1, s.markup = c ? i + i : i, s.content = "", s = n.tokens[o.token], s.type = c ? "strong_close" : "em_close", s.tag = c ? "strong" : "em", s.nesting = -1, s.markup = c ? i + i : i, s.content = "", c && (n.tokens[e[t - 1].token].content = "", n.tokens[e[r.end + 1].token].content = "", t--));
}
vn.postProcess = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Kt(e, e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Kt(e, r[t].delimiters);
};
var A4 = $.normalizeReference;
var qn = $.isSpace;
var C4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p, f = "", h5 = "", d = e.pos, g = e.posMax, E = e.pos, x = true;
  if (e.src.charCodeAt(e.pos) !== 91 || (c = e.pos + 1, i = e.md.helpers.parseLinkLabel(e, e.pos, true), i < 0))
    return false;
  if (a = i + 1, a < g && e.src.charCodeAt(a) === 40) {
    for (x = false, a++; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
      ;
    if (a >= g)
      return false;
    if (E = a, l = e.md.helpers.parseLinkDestination(e.src, a, e.posMax), l.ok) {
      for (f = e.md.normalizeLink(l.str), e.md.validateLink(f) ? a = l.pos : f = "", E = a; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
        ;
      if (l = e.md.helpers.parseLinkTitle(e.src, a, e.posMax), a < g && E !== a && l.ok)
        for (h5 = l.str, a = l.pos; a < g && (o = e.src.charCodeAt(a), !(!qn(o) && o !== 10)); a++)
          ;
    }
    (a >= g || e.src.charCodeAt(a) !== 41) && (x = true), a++;
  }
  if (x) {
    if (typeof e.env.references > "u")
      return false;
    if (a < g && e.src.charCodeAt(a) === 91 ? (E = a + 1, a = e.md.helpers.parseLinkLabel(e, a), a >= 0 ? s = e.src.slice(E, a++) : a = i + 1) : a = i + 1, s || (s = e.src.slice(c, i)), u = e.env.references[A4(s)], !u)
      return e.pos = d, false;
    f = u.href, h5 = u.title;
  }
  return t || (e.pos = c, e.posMax = i, p = e.push("link_open", "a", 1), p.attrs = r = [["href", f]], h5 && r.push(["title", h5]), e.linkLevel++, e.md.inline.tokenize(e), e.linkLevel--, p = e.push("link_close", "a", -1)), e.pos = a, e.posMax = g, true;
};
var S4 = $.normalizeReference;
var Mn = $.isSpace;
var D4 = function(e, t) {
  var r, o, s, i, c, a, l, u, p, f, h5, d, g, E = "", x = e.pos, b = e.posMax;
  if (e.src.charCodeAt(e.pos) !== 33 || e.src.charCodeAt(e.pos + 1) !== 91 || (a = e.pos + 2, c = e.md.helpers.parseLinkLabel(e, e.pos + 1, false), c < 0))
    return false;
  if (l = c + 1, l < b && e.src.charCodeAt(l) === 40) {
    for (l++; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (l >= b)
      return false;
    for (g = l, p = e.md.helpers.parseLinkDestination(e.src, l, e.posMax), p.ok && (E = e.md.normalizeLink(p.str), e.md.validateLink(E) ? l = p.pos : E = ""), g = l; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
      ;
    if (p = e.md.helpers.parseLinkTitle(e.src, l, e.posMax), l < b && g !== l && p.ok)
      for (f = p.str, l = p.pos; l < b && (o = e.src.charCodeAt(l), !(!Mn(o) && o !== 10)); l++)
        ;
    else
      f = "";
    if (l >= b || e.src.charCodeAt(l) !== 41)
      return e.pos = x, false;
    l++;
  } else {
    if (typeof e.env.references > "u")
      return false;
    if (l < b && e.src.charCodeAt(l) === 91 ? (g = l + 1, l = e.md.helpers.parseLinkLabel(e, l), l >= 0 ? i = e.src.slice(g, l++) : l = c + 1) : l = c + 1, i || (i = e.src.slice(a, c)), u = e.env.references[S4(i)], !u)
      return e.pos = x, false;
    E = u.href, f = u.title;
  }
  return t || (s = e.src.slice(a, c), e.md.inline.parse(
    s,
    e.md,
    e.env,
    d = []
  ), h5 = e.push("image", "img", 0), h5.attrs = r = [["src", E], ["alt", ""]], h5.children = d, h5.content = s, f && r.push(["title", f])), e.pos = l, e.posMax = b, true;
};
var T4 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var R4 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var L4 = function(e, t) {
  var r, o, s, i, c, a, l = e.pos;
  if (e.src.charCodeAt(l) !== 60)
    return false;
  for (c = e.pos, a = e.posMax; ; ) {
    if (++l >= a || (i = e.src.charCodeAt(l), i === 60))
      return false;
    if (i === 62)
      break;
  }
  return r = e.src.slice(c + 1, l), R4.test(r) ? (o = e.md.normalizeLink(r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, true) : false) : T4.test(r) ? (o = e.md.normalizeLink("mailto:" + r), e.md.validateLink(o) ? (t || (s = e.push("link_open", "a", 1), s.attrs = [["href", o]], s.markup = "autolink", s.info = "auto", s = e.push("text", "", 0), s.content = e.md.normalizeLinkText(r), s = e.push("link_close", "a", -1), s.markup = "autolink", s.info = "auto"), e.pos += r.length + 2, true) : false) : false;
};
var N4 = gn.HTML_TAG_RE;
function q4(n) {
  return /^<a[>\s]/i.test(n);
}
function M4(n) {
  return /^<\/a\s*>/i.test(n);
}
function I4(n) {
  var e = n | 32;
  return e >= 97 && e <= 122;
}
var O4 = function(e, t) {
  var r, o, s, i, c = e.pos;
  return !e.md.options.html || (s = e.posMax, e.src.charCodeAt(c) !== 60 || c + 2 >= s) || (r = e.src.charCodeAt(c + 1), r !== 33 && r !== 63 && r !== 47 && !I4(r)) || (o = e.src.slice(c).match(N4), !o) ? false : (t || (i = e.push("html_inline", "", 0), i.content = o[0], q4(i.content) && e.linkLevel++, M4(i.content) && e.linkLevel--), e.pos += o[0].length, true);
};
var Wt = zr;
var F4 = $.has;
var B4 = $.isValidEntityCode;
var Yt = $.fromCodePoint;
var P4 = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var $4 = /^&([a-z][a-z0-9]{1,31});/i;
var z4 = function(e, t) {
  var r, o, s, i, c = e.pos, a = e.posMax;
  if (e.src.charCodeAt(c) !== 38 || c + 1 >= a)
    return false;
  if (r = e.src.charCodeAt(c + 1), r === 35) {
    if (s = e.src.slice(c).match(P4), s)
      return t || (o = s[1][0].toLowerCase() === "x" ? parseInt(s[1].slice(1), 16) : parseInt(s[1], 10), i = e.push("text_special", "", 0), i.content = B4(o) ? Yt(o) : Yt(65533), i.markup = s[0], i.info = "entity"), e.pos += s[0].length, true;
  } else if (s = e.src.slice(c).match($4), s && F4(Wt, s[1]))
    return t || (i = e.push("text_special", "", 0), i.content = Wt[s[1]], i.markup = s[0], i.info = "entity"), e.pos += s[0].length, true;
  return false;
};
function Jt(n) {
  var e, t, r, o, s, i, c, a, l = {}, u = n.length;
  if (u) {
    var p = 0, f = -2, h5 = [];
    for (e = 0; e < u; e++)
      if (r = n[e], h5.push(0), (n[p].marker !== r.marker || f !== r.token - 1) && (p = e), f = r.token, r.length = r.length || 0, !!r.close) {
        for (l.hasOwnProperty(r.marker) || (l[r.marker] = [-1, -1, -1, -1, -1, -1]), s = l[r.marker][(r.open ? 3 : 0) + r.length % 3], t = p - h5[p] - 1, i = t; t > s; t -= h5[t] + 1)
          if (o = n[t], o.marker === r.marker && o.open && o.end < 0 && (c = false, (o.close || r.open) && (o.length + r.length) % 3 === 0 && (o.length % 3 !== 0 || r.length % 3 !== 0) && (c = true), !c)) {
            a = t > 0 && !n[t - 1].open ? h5[t - 1] + 1 : 0, h5[e] = e - t + a, h5[t] = a, r.open = false, o.end = e, o.close = false, i = -1, f = -2;
            break;
          }
        i !== -1 && (l[r.marker][(r.open ? 3 : 0) + (r.length || 0) % 3] = i);
      }
  }
}
var U4 = function(e) {
  var t, r = e.tokens_meta, o = e.tokens_meta.length;
  for (Jt(e.delimiters), t = 0; t < o; t++)
    r[t] && r[t].delimiters && Jt(r[t].delimiters);
};
var H4 = function(e) {
  var t, r, o = 0, s = e.tokens, i = e.tokens.length;
  for (t = r = 0; t < i; t++)
    s[t].nesting < 0 && o--, s[t].level = o, s[t].nesting > 0 && o++, s[t].type === "text" && t + 1 < i && s[t + 1].type === "text" ? s[t + 1].content = s[t].content + s[t + 1].content : (t !== r && (s[r] = s[t]), r++);
  t !== r && (s.length = r);
};
var tt = Qn;
var Xt = $.isWhiteSpace;
var Qt = $.isPunctChar;
var er = $.isMdAsciiPunct;
function je(n, e, t, r) {
  this.src = n, this.env = t, this.md = e, this.tokens = r, this.tokens_meta = Array(r.length), this.pos = 0, this.posMax = this.src.length, this.level = 0, this.pending = "", this.pendingLevel = 0, this.cache = {}, this.delimiters = [], this._prev_delimiters = [], this.backticks = {}, this.backticksScanned = false, this.linkLevel = 0;
}
je.prototype.pushPending = function() {
  var n = new tt("text", "", 0);
  return n.content = this.pending, n.level = this.pendingLevel, this.tokens.push(n), this.pending = "", n;
};
je.prototype.push = function(n, e, t) {
  this.pending && this.pushPending();
  var r = new tt(n, e, t), o = null;
  return t < 0 && (this.level--, this.delimiters = this._prev_delimiters.pop()), r.level = this.level, t > 0 && (this.level++, this._prev_delimiters.push(this.delimiters), this.delimiters = [], o = { delimiters: this.delimiters }), this.pendingLevel = this.level, this.tokens.push(r), this.tokens_meta.push(o), r;
};
je.prototype.scanDelims = function(n, e) {
  var t = n, r, o, s, i, c, a, l, u, p, f = true, h5 = true, d = this.posMax, g = this.src.charCodeAt(n);
  for (r = n > 0 ? this.src.charCodeAt(n - 1) : 32; t < d && this.src.charCodeAt(t) === g; )
    t++;
  return s = t - n, o = t < d ? this.src.charCodeAt(t) : 32, l = er(r) || Qt(String.fromCharCode(r)), p = er(o) || Qt(String.fromCharCode(o)), a = Xt(r), u = Xt(o), u ? f = false : p && (a || l || (f = false)), a ? h5 = false : l && (u || p || (h5 = false)), e ? (i = f, c = h5) : (i = f && (!h5 || l), c = h5 && (!f || p)), {
    can_open: i,
    can_close: c,
    length: s
  };
};
je.prototype.Token = tt;
var V4 = je;
var nr = Xn;
var In = [
  ["text", _4],
  ["linkify", v4],
  ["newline", x4],
  ["escape", E4],
  ["backticks", w4],
  ["strikethrough", bn.tokenize],
  ["emphasis", vn.tokenize],
  ["link", C4],
  ["image", D4],
  ["autolink", L4],
  ["html_inline", O4],
  ["entity", z4]
];
var On = [
  ["balance_pairs", U4],
  ["strikethrough", bn.postProcess],
  ["emphasis", vn.postProcess],
  // rules for pairs separate '**' into its own text tokens, which may be left unused,
  // rule below merges unused segments back with the rest of the text
  ["fragments_join", H4]
];
function Ze() {
  var n;
  for (this.ruler = new nr(), n = 0; n < In.length; n++)
    this.ruler.push(In[n][0], In[n][1]);
  for (this.ruler2 = new nr(), n = 0; n < On.length; n++)
    this.ruler2.push(On[n][0], On[n][1]);
}
Ze.prototype.skipToken = function(n) {
  var e, t, r = n.pos, o = this.ruler.getRules(""), s = o.length, i = n.md.options.maxNesting, c = n.cache;
  if (typeof c[r] < "u") {
    n.pos = c[r];
    return;
  }
  if (n.level < i) {
    for (t = 0; t < s; t++)
      if (n.level++, e = o[t](n, true), n.level--, e) {
        if (r >= n.pos)
          throw new Error("inline rule didn't increment state.pos");
        break;
      }
  } else
    n.pos = n.posMax;
  e || n.pos++, c[r] = n.pos;
};
Ze.prototype.tokenize = function(n) {
  for (var e, t, r, o = this.ruler.getRules(""), s = o.length, i = n.posMax, c = n.md.options.maxNesting; n.pos < i; ) {
    if (r = n.pos, n.level < c) {
      for (t = 0; t < s; t++)
        if (e = o[t](n, false), e) {
          if (r >= n.pos)
            throw new Error("inline rule didn't increment state.pos");
          break;
        }
    }
    if (e) {
      if (n.pos >= i)
        break;
      continue;
    }
    n.pending += n.src[n.pos++];
  }
  n.pending && n.pushPending();
};
Ze.prototype.parse = function(n, e, t, r) {
  var o, s, i, c = new this.State(n, e, t, r);
  for (this.tokenize(c), s = this.ruler2.getRules(""), i = s.length, o = 0; o < i; o++)
    s[o](c);
};
Ze.prototype.State = V4;
var G4 = Ze;
var Fn;
var tr;
function j4() {
  return tr || (tr = 1, Fn = function(n) {
    var e = {};
    n = n || {}, e.src_Any = Ur().source, e.src_Cc = Hr().source, e.src_Z = Vr().source, e.src_P = Jn.source, e.src_ZPCc = [e.src_Z, e.src_P, e.src_Cc].join("|"), e.src_ZCc = [e.src_Z, e.src_Cc].join("|");
    var t = "[><｜]";
    return e.src_pseudo_letter = "(?:(?!" + t + "|" + e.src_ZPCc + ")" + e.src_Any + ")", e.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", e.src_auth = "(?:(?:(?!" + e.src_ZCc + "|[@/\\[\\]()]).)+@)?", e.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", e.src_host_terminator = "(?=$|" + t + "|" + e.src_ZPCc + ")(?!" + (n["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + e.src_ZPCc + "))", e.src_path = "(?:[/?#](?:(?!" + e.src_ZCc + "|" + t + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + e.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + e.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + e.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + e.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + e.src_ZCc + "|[']).)+\\'|\\'(?=" + e.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + e.src_ZCc + "|[.]|$)|" + (n["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + e.src_ZCc + "|$)|;(?!" + e.src_ZCc + "|$)|\\!+(?!" + e.src_ZCc + "|[!]|$)|\\?(?!" + e.src_ZCc + "|[?]|$))+|\\/)?", e.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*', e.src_xn = "xn--[a-z0-9\\-]{1,59}", e.src_domain_root = // Allow letters & digits (http://test1)
    "(?:" + e.src_xn + "|" + e.src_pseudo_letter + "{1,63})", e.src_domain = "(?:" + e.src_xn + "|(?:" + e.src_pseudo_letter + ")|(?:" + e.src_pseudo_letter + "(?:-|" + e.src_pseudo_letter + "){0,61}" + e.src_pseudo_letter + "))", e.src_host = "(?:(?:(?:(?:" + e.src_domain + ")\\.)*" + e.src_domain + "))", e.tpl_host_fuzzy = "(?:" + e.src_ip4 + "|(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%)))", e.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + e.src_domain + ")\\.)+(?:%TLDS%))", e.src_host_strict = e.src_host + e.src_host_terminator, e.tpl_host_fuzzy_strict = e.tpl_host_fuzzy + e.src_host_terminator, e.src_host_port_strict = e.src_host + e.src_port + e.src_host_terminator, e.tpl_host_port_fuzzy_strict = e.tpl_host_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_port_no_ip_fuzzy_strict = e.tpl_host_no_ip_fuzzy + e.src_port + e.src_host_terminator, e.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + e.src_ZPCc + "|>|$))", e.tpl_email_fuzzy = "(^|" + t + '|"|\\(|' + e.src_ZCc + ")(" + e.src_email_name + "@" + e.tpl_host_fuzzy_strict + ")", e.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_fuzzy_strict + e.src_path + ")", e.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
    // but can start with > (markdown blockquote)
    "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + e.src_ZPCc + "))((?![$+<=>^`|｜])" + e.tpl_host_port_no_ip_fuzzy_strict + e.src_path + ")", e;
  }), Fn;
}
function zn(n) {
  var e = Array.prototype.slice.call(arguments, 1);
  return e.forEach(function(t) {
    t && Object.keys(t).forEach(function(r) {
      n[r] = t[r];
    });
  }), n;
}
function kn(n) {
  return Object.prototype.toString.call(n);
}
function Z4(n) {
  return kn(n) === "[object String]";
}
function K4(n) {
  return kn(n) === "[object Object]";
}
function W4(n) {
  return kn(n) === "[object RegExp]";
}
function rr(n) {
  return kn(n) === "[object Function]";
}
function Y4(n) {
  return n.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var Jr = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function J4(n) {
  return Object.keys(n || {}).reduce(function(e, t) {
    return e || Jr.hasOwnProperty(t);
  }, false);
}
var X4 = {
  "http:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.http || (t.re.http = new RegExp(
        "^\\/\\/" + t.re.src_auth + t.re.src_host_port_strict + t.re.src_path,
        "i"
      )), t.re.http.test(r) ? r.match(t.re.http)[0].length : 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.no_http || (t.re.no_http = new RegExp(
        "^" + t.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        "(?:localhost|(?:(?:" + t.re.src_domain + ")\\.)+" + t.re.src_domain_root + ")" + t.re.src_port + t.re.src_host_terminator + t.re.src_path,
        "i"
      )), t.re.no_http.test(r) ? e >= 3 && n[e - 3] === ":" || e >= 3 && n[e - 3] === "/" ? 0 : r.match(t.re.no_http)[0].length : 0;
    }
  },
  "mailto:": {
    validate: function(n, e, t) {
      var r = n.slice(e);
      return t.re.mailto || (t.re.mailto = new RegExp(
        "^" + t.re.src_email_name + "@" + t.re.src_host_strict,
        "i"
      )), t.re.mailto.test(r) ? r.match(t.re.mailto)[0].length : 0;
    }
  }
};
var Q4 = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var e8 = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
function n8(n) {
  n.__index__ = -1, n.__text_cache__ = "";
}
function t8(n) {
  return function(e, t) {
    var r = e.slice(t);
    return n.test(r) ? r.match(n)[0].length : 0;
  };
}
function or() {
  return function(n, e) {
    e.normalize(n);
  };
}
function an(n) {
  var e = n.re = j4()(n.__opts__), t = n.__tlds__.slice();
  n.onCompile(), n.__tlds_replaced__ || t.push(Q4), t.push(e.src_xn), e.src_tlds = t.join("|");
  function r(c) {
    return c.replace("%TLDS%", e.src_tlds);
  }
  e.email_fuzzy = RegExp(r(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(r(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(r(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(r(e.tpl_host_fuzzy_test), "i");
  var o = [];
  n.__compiled__ = {};
  function s(c, a) {
    throw new Error('(LinkifyIt) Invalid schema "' + c + '": ' + a);
  }
  Object.keys(n.__schemas__).forEach(function(c) {
    var a = n.__schemas__[c];
    if (a !== null) {
      var l = { validate: null, link: null };
      if (n.__compiled__[c] = l, K4(a)) {
        W4(a.validate) ? l.validate = t8(a.validate) : rr(a.validate) ? l.validate = a.validate : s(c, a), rr(a.normalize) ? l.normalize = a.normalize : a.normalize ? s(c, a) : l.normalize = or();
        return;
      }
      if (Z4(a)) {
        o.push(c);
        return;
      }
      s(c, a);
    }
  }), o.forEach(function(c) {
    n.__compiled__[n.__schemas__[c]] && (n.__compiled__[c].validate = n.__compiled__[n.__schemas__[c]].validate, n.__compiled__[c].normalize = n.__compiled__[n.__schemas__[c]].normalize);
  }), n.__compiled__[""] = { validate: null, normalize: or() };
  var i = Object.keys(n.__compiled__).filter(function(c) {
    return c.length > 0 && n.__compiled__[c];
  }).map(Y4).join("|");
  n.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "i"), n.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + e.src_ZPCc + "))(" + i + ")", "ig"), n.re.schema_at_start = RegExp("^" + n.re.schema_search.source, "i"), n.re.pretest = RegExp(
    "(" + n.re.schema_test.source + ")|(" + n.re.host_fuzzy_test.source + ")|@",
    "i"
  ), n8(n);
}
function r8(n, e) {
  var t = n.__index__, r = n.__last_index__, o = n.__text_cache__.slice(t, r);
  this.schema = n.__schema__.toLowerCase(), this.index = t + e, this.lastIndex = r + e, this.raw = o, this.text = o, this.url = o;
}
function Un(n, e) {
  var t = new r8(n, e);
  return n.__compiled__[t.schema].normalize(t, n), t;
}
function ce(n, e) {
  if (!(this instanceof ce))
    return new ce(n, e);
  e || J4(n) && (e = n, n = {}), this.__opts__ = zn({}, Jr, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = zn({}, X4, n), this.__compiled__ = {}, this.__tlds__ = e8, this.__tlds_replaced__ = false, this.re = {}, an(this);
}
ce.prototype.add = function(e, t) {
  return this.__schemas__[e] = t, an(this), this;
};
ce.prototype.set = function(e) {
  return this.__opts__ = zn(this.__opts__, e), this;
};
ce.prototype.test = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return false;
  var t, r, o, s, i, c, a, l, u;
  if (this.re.schema_test.test(e)) {
    for (a = this.re.schema_search, a.lastIndex = 0; (t = a.exec(e)) !== null; )
      if (s = this.testSchemaAt(e, t[2], a.lastIndex), s) {
        this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + s;
        break;
      }
  }
  return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (l = e.search(this.re.host_fuzzy_test), l >= 0 && (this.__index__ < 0 || l < this.__index__) && (r = e.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null && (i = r.index + r[1].length, (this.__index__ < 0 || i < this.__index__) && (this.__schema__ = "", this.__index__ = i, this.__last_index__ = r.index + r[0].length))), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && (u = e.indexOf("@"), u >= 0 && (o = e.match(this.re.email_fuzzy)) !== null && (i = o.index + o[1].length, c = o.index + o[0].length, (this.__index__ < 0 || i < this.__index__ || i === this.__index__ && c > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = i, this.__last_index__ = c))), this.__index__ >= 0;
};
ce.prototype.pretest = function(e) {
  return this.re.pretest.test(e);
};
ce.prototype.testSchemaAt = function(e, t, r) {
  return this.__compiled__[t.toLowerCase()] ? this.__compiled__[t.toLowerCase()].validate(e, r, this) : 0;
};
ce.prototype.match = function(e) {
  var t = 0, r = [];
  this.__index__ >= 0 && this.__text_cache__ === e && (r.push(Un(this, t)), t = this.__last_index__);
  for (var o = t ? e.slice(t) : e; this.test(o); )
    r.push(Un(this, t)), o = o.slice(this.__last_index__), t += this.__last_index__;
  return r.length ? r : null;
};
ce.prototype.matchAtStart = function(e) {
  if (this.__text_cache__ = e, this.__index__ = -1, !e.length)
    return null;
  var t = this.re.schema_at_start.exec(e);
  if (!t)
    return null;
  var r = this.testSchemaAt(e, t[2], t[0].length);
  return r ? (this.__schema__ = t[2], this.__index__ = t.index + t[1].length, this.__last_index__ = t.index + t[0].length + r, Un(this, 0)) : null;
};
ce.prototype.tlds = function(e, t) {
  return e = Array.isArray(e) ? e : [e], t ? (this.__tlds__ = this.__tlds__.concat(e).sort().filter(function(r, o, s) {
    return r !== s[o - 1];
  }).reverse(), an(this), this) : (this.__tlds__ = e.slice(), this.__tlds_replaced__ = true, an(this), this);
};
ce.prototype.normalize = function(e) {
  e.schema || (e.url = "http://" + e.url), e.schema === "mailto:" && !/^mailto:/i.test(e.url) && (e.url = "mailto:" + e.url);
};
ce.prototype.onCompile = function() {
};
var o8 = ce;
var Le = 2147483647;
var pe = 36;
var rt = 1;
var Ve = 26;
var s8 = 38;
var c8 = 700;
var Xr = 72;
var Qr = 128;
var eo = "-";
var i8 = /^xn--/;
var a8 = /[^\0-\x7F]/;
var l8 = /[\x2E\u3002\uFF0E\uFF61]/g;
var u8 = {
  overflow: "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
var Bn = pe - rt;
var he = Math.floor;
var Pn = String.fromCharCode;
function ve(n) {
  throw new RangeError(u8[n]);
}
function f8(n, e) {
  const t = [];
  let r = n.length;
  for (; r--; )
    t[r] = e(n[r]);
  return t;
}
function no(n, e) {
  const t = n.split("@");
  let r = "";
  t.length > 1 && (r = t[0] + "@", n = t[1]), n = n.replace(l8, ".");
  const o = n.split("."), s = f8(o, e).join(".");
  return r + s;
}
function ot(n) {
  const e = [];
  let t = 0;
  const r = n.length;
  for (; t < r; ) {
    const o = n.charCodeAt(t++);
    if (o >= 55296 && o <= 56319 && t < r) {
      const s = n.charCodeAt(t++);
      (s & 64512) == 56320 ? e.push(((o & 1023) << 10) + (s & 1023) + 65536) : (e.push(o), t--);
    } else
      e.push(o);
  }
  return e;
}
var to = (n) => String.fromCodePoint(...n);
var p8 = function(n) {
  return n >= 48 && n < 58 ? 26 + (n - 48) : n >= 65 && n < 91 ? n - 65 : n >= 97 && n < 123 ? n - 97 : pe;
};
var sr = function(n, e) {
  return n + 22 + 75 * (n < 26) - ((e != 0) << 5);
};
var ro = function(n, e, t) {
  let r = 0;
  for (n = t ? he(n / c8) : n >> 1, n += he(n / e); n > Bn * Ve >> 1; r += pe)
    n = he(n / Bn);
  return he(r + (Bn + 1) * n / (n + s8));
};
var st = function(n) {
  const e = [], t = n.length;
  let r = 0, o = Qr, s = Xr, i = n.lastIndexOf(eo);
  i < 0 && (i = 0);
  for (let c = 0; c < i; ++c)
    n.charCodeAt(c) >= 128 && ve("not-basic"), e.push(n.charCodeAt(c));
  for (let c = i > 0 ? i + 1 : 0; c < t; ) {
    const a = r;
    for (let u = 1, p = pe; ; p += pe) {
      c >= t && ve("invalid-input");
      const f = p8(n.charCodeAt(c++));
      f >= pe && ve("invalid-input"), f > he((Le - r) / u) && ve("overflow"), r += f * u;
      const h5 = p <= s ? rt : p >= s + Ve ? Ve : p - s;
      if (f < h5)
        break;
      const d = pe - h5;
      u > he(Le / d) && ve("overflow"), u *= d;
    }
    const l = e.length + 1;
    s = ro(r - a, l, a == 0), he(r / l) > Le - o && ve("overflow"), o += he(r / l), r %= l, e.splice(r++, 0, o);
  }
  return String.fromCodePoint(...e);
};
var ct = function(n) {
  const e = [];
  n = ot(n);
  const t = n.length;
  let r = Qr, o = 0, s = Xr;
  for (const a of n)
    a < 128 && e.push(Pn(a));
  const i = e.length;
  let c = i;
  for (i && e.push(eo); c < t; ) {
    let a = Le;
    for (const u of n)
      u >= r && u < a && (a = u);
    const l = c + 1;
    a - r > he((Le - o) / l) && ve("overflow"), o += (a - r) * l, r = a;
    for (const u of n)
      if (u < r && ++o > Le && ve("overflow"), u === r) {
        let p = o;
        for (let f = pe; ; f += pe) {
          const h5 = f <= s ? rt : f >= s + Ve ? Ve : f - s;
          if (p < h5)
            break;
          const d = p - h5, g = pe - h5;
          e.push(
            Pn(sr(h5 + d % g, 0))
          ), p = he(d / g);
        }
        e.push(Pn(sr(p, 0))), s = ro(o, l, c === i), o = 0, ++c;
      }
    ++o, ++r;
  }
  return e.join("");
};
var oo = function(n) {
  return no(n, function(e) {
    return i8.test(e) ? st(e.slice(4).toLowerCase()) : e;
  });
};
var so = function(n) {
  return no(n, function(e) {
    return a8.test(e) ? "xn--" + ct(e) : e;
  });
};
var h8 = {
  /**
   * A string representing the current Punycode.js version number.
   * @memberOf punycode
   * @type String
   */
  version: "2.3.1",
  /**
   * An object of methods to convert from JavaScript's internal character
   * representation (UCS-2) to Unicode code points, and back.
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode
   * @type Object
   */
  ucs2: {
    decode: ot,
    encode: to
  },
  decode: st,
  encode: ct,
  toASCII: so,
  toUnicode: oo
};
var d8 = Object.freeze(Object.defineProperty({
  __proto__: null,
  decode: st,
  default: h8,
  encode: ct,
  toASCII: so,
  toUnicode: oo,
  ucs2decode: ot,
  ucs2encode: to
}, Symbol.toStringTag, { value: "Module" }));
var g8 = Zo(d8);
var m8 = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100
    // Internal protection, recursion limit
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var _8 = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "fragments_join"
      ]
    }
  }
};
var b8 = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: "language-",
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: "“”‘’",
    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20
    // Internal protection, recursion limit
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline",
        "text_join"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "fragments_join"
      ]
    }
  }
};
var Pe = $;
var v8 = dn;
var k8 = p9;
var x8 = O9;
var y8 = g4;
var E8 = G4;
var w8 = o8;
var we = Me;
var co = g8;
var A8 = {
  default: m8,
  zero: _8,
  commonmark: b8
};
var C8 = /^(vbscript|javascript|file|data):/;
var S8 = /^data:image\/(gif|png|jpeg|webp);/;
function D8(n) {
  var e = n.trim().toLowerCase();
  return C8.test(e) ? !!S8.test(e) : true;
}
var io = ["http:", "https:", "mailto:"];
function T8(n) {
  var e = we.parse(n, true);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toASCII(e.hostname);
    } catch {
    }
  return we.encode(we.format(e));
}
function R8(n) {
  var e = we.parse(n, true);
  if (e.hostname && (!e.protocol || io.indexOf(e.protocol) >= 0))
    try {
      e.hostname = co.toUnicode(e.hostname);
    } catch {
    }
  return we.decode(we.format(e), we.decode.defaultChars + "%");
}
function ie(n, e) {
  if (!(this instanceof ie))
    return new ie(n, e);
  e || Pe.isString(n) || (e = n || {}, n = "default"), this.inline = new E8(), this.block = new y8(), this.core = new x8(), this.renderer = new k8(), this.linkify = new w8(), this.validateLink = D8, this.normalizeLink = T8, this.normalizeLinkText = R8, this.utils = Pe, this.helpers = Pe.assign({}, v8), this.options = {}, this.configure(n), e && this.set(e);
}
ie.prototype.set = function(n) {
  return Pe.assign(this.options, n), this;
};
ie.prototype.configure = function(n) {
  var e = this, t;
  if (Pe.isString(n) && (t = n, n = A8[t], !n))
    throw new Error('Wrong `markdown-it` preset "' + t + '", check name');
  if (!n)
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  return n.options && e.set(n.options), n.components && Object.keys(n.components).forEach(function(r) {
    n.components[r].rules && e[r].ruler.enableOnly(n.components[r].rules), n.components[r].rules2 && e[r].ruler2.enableOnly(n.components[r].rules2);
  }), this;
};
ie.prototype.enable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.enable(n, true));
  }, this), t = t.concat(this.inline.ruler2.enable(n, true));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + r);
  return this;
};
ie.prototype.disable = function(n, e) {
  var t = [];
  Array.isArray(n) || (n = [n]), ["core", "block", "inline"].forEach(function(o) {
    t = t.concat(this[o].ruler.disable(n, true));
  }, this), t = t.concat(this.inline.ruler2.disable(n, true));
  var r = n.filter(function(o) {
    return t.indexOf(o) < 0;
  });
  if (r.length && !e)
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + r);
  return this;
};
ie.prototype.use = function(n) {
  var e = [this].concat(Array.prototype.slice.call(arguments, 1));
  return n.apply(n, e), this;
};
ie.prototype.parse = function(n, e) {
  if (typeof n != "string")
    throw new Error("Input data should be a String");
  var t = new this.core.State(n, this, e);
  return this.core.process(t), t.tokens;
};
ie.prototype.render = function(n, e) {
  return e = e || {}, this.renderer.render(this.parse(n, e), this.options, e);
};
ie.prototype.parseInline = function(n, e) {
  var t = new this.core.State(n, this, e);
  return t.inlineMode = true, this.core.process(t), t.tokens;
};
ie.prototype.renderInline = function(n, e) {
  return e = e || {}, this.renderer.render(this.parseInline(n, e), this.options, e);
};
var L8 = ie;
var N8 = L8;
var q8 = Gn(N8);
var M8 = defineComponent({
  name: "VueMarkdown",
  props: {
    source: {
      type: String,
      required: true
    },
    options: {
      type: Object,
      required: false
    },
    plugins: {
      type: Array,
      required: false
    }
  },
  setup(n) {
    const e = ref(new q8(n.options ?? {}));
    for (const r of n.plugins ?? [])
      e.value.use(r);
    const t = computed(() => e.value.render(n.source));
    return () => h("div", { innerHTML: t.value });
  }
});
var I8 = {
  key: 0,
  class: "chat-message-actions"
};
var O8 = {
  key: 2,
  class: "chat-message-files"
};
var Hn = defineComponent({
  __name: "Message",
  props: {
    message: {}
  },
  setup(n, { expose: e }) {
    const t = n;
    be.registerLanguage("javascript", Rr), be.registerLanguage("typescript", vi), be.registerLanguage("python", _i), be.registerLanguage("xml", Lr), be.registerLanguage("bash", mi);
    const { message: r } = toRefs(t), { options: o } = Ge(), s = ref(null), i = ref({}), c = computed(() => r.value.text || "&lt;Empty response&gt;"), a = computed(() => ({
      "chat-message-from-user": r.value.sender === "user",
      "chat-message-from-bot": r.value.sender === "bot",
      "chat-message-transparent": r.value.transparent === true
    })), l = (d) => {
      d.use(Ei, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
    }, u = () => {
      var d;
      (d = s.value) != null && d.scrollIntoView && s.value.scrollIntoView({
        block: "center"
      });
    }, p = {
      highlight(d, g) {
        if (g && be.getLanguage(g))
          try {
            return be.highlight(d, { language: g }).value;
          } catch {
          }
        return "";
      }
    }, f = { ...(o == null ? void 0 : o.messageComponents) ?? {} };
    e({ scrollToView: u });
    const h5 = async (d) => await new Promise((g, E) => {
      const x = new FileReader();
      x.onload = () => g(x.result), x.onerror = E, x.readAsDataURL(d);
    });
    return onMounted(async () => {
      if (r.value.files)
        for (const d of r.value.files)
          try {
            const g = await h5(d);
            i.value[d.name] = g;
          } catch (g) {
            console.error("Error reading file:", g);
          }
    }), (d, g) => (openBlock(), createElementBlock("div", {
      ref_key: "messageContainer",
      ref: s,
      class: normalizeClass(["chat-message", a.value])
    }, [
      d.$slots.beforeMessage ? (openBlock(), createElementBlock("div", I8, [
        renderSlot(d.$slots, "beforeMessage", normalizeProps(guardReactiveProps({ message: unref(r) })))
      ])) : createCommentVNode("", true),
      renderSlot(d.$slots, "default", {}, () => [
        unref(r).type === "component" && f[unref(r).key] ? (openBlock(), createBlock(resolveDynamicComponent(f[unref(r).key]), normalizeProps(mergeProps({ key: 0 }, unref(r).arguments)), null, 16)) : (openBlock(), createBlock(unref(M8), {
          key: 1,
          class: "chat-message-markdown",
          source: c.value,
          options: p,
          plugins: [l]
        }, null, 8, ["source", "plugins"])),
        (unref(r).files ?? []).length > 0 ? (openBlock(), createElementBlock("div", O8, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(r).files ?? [], (E) => (openBlock(), createElementBlock("div", {
            key: E.name,
            class: "chat-message-file"
          }, [
            createVNode(Nr, {
              file: E,
              "is-removable": false,
              "is-previewable": true
            }, null, 8, ["file"])
          ]))), 128))
        ])) : createCommentVNode("", true)
      ])
    ], 2));
  }
});
var F8 = createBaseVNode("div", { class: "chat-message-typing-body" }, [
  createBaseVNode("span", { class: "chat-message-typing-circle" }),
  createBaseVNode("span", { class: "chat-message-typing-circle" }),
  createBaseVNode("span", { class: "chat-message-typing-circle" })
], -1);
var B8 = defineComponent({
  __name: "MessageTyping",
  props: {
    animation: { default: "bouncing" }
  },
  setup(n) {
    const e = n, t = {
      id: "typing",
      text: "",
      sender: "bot",
      createdAt: ""
    }, r = ref(), o = computed(() => ({
      // eslint-disable-next-line @typescript-eslint/naming-convention
      "chat-message-typing": true,
      [`chat-message-typing-animation-${e.animation}`]: true
    }));
    return onMounted(() => {
      var s;
      (s = r.value) == null || s.scrollToView();
    }), (s, i) => (openBlock(), createBlock(unref(Hn), {
      ref_key: "messageContainer",
      ref: r,
      class: normalizeClass(o.value),
      message: t
    }, {
      default: withCtx(() => [
        F8
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
var P8 = { class: "chat-messages-list" };
var $8 = defineComponent({
  __name: "MessagesList",
  props: {
    messages: {}
  },
  setup(n) {
    const e = Yn(), t = ref([]), { initialMessages: r, waitingForResponse: o } = e;
    return watch(
      () => t.value.length,
      () => {
        const s = t.value[t.value.length - 1];
        s && s.scrollToView();
      }
    ), (s, i) => (openBlock(), createElementBlock("div", P8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(unref(r), (c) => (openBlock(), createBlock(Hn, {
        key: c.id,
        message: c
      }, null, 8, ["message"]))), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.messages, (c) => (openBlock(), createBlock(Hn, {
        key: c.id,
        ref_for: true,
        ref_key: "messageComponents",
        ref: t,
        message: c
      }, {
        beforeMessage: withCtx(({ message: a }) => [
          renderSlot(s.$slots, "beforeMessage", normalizeProps(guardReactiveProps({ message: a })))
        ]),
        _: 2
      }, 1032, ["message"]))), 128)),
      unref(o) ? (openBlock(), createBlock(B8, { key: 0 })) : createCommentVNode("", true)
    ]));
  }
});
var z8 = { class: "chat-heading" };
var U8 = ["title"];
var H8 = { key: 0 };
var ao = defineComponent({
  __name: "Chat",
  setup(n) {
    const { t: e } = fn(), t = Yn(), { messages: r, currentSessionId: o } = t, { options: s } = Ge(), i = computed(() => s.mode === "window" && s.showWindowCloseButton);
    async function c() {
      t.startNewSession && (t.startNewSession(), nextTick(() => {
        re.emit("scrollToBottom");
      }));
    }
    async function a() {
      t.loadPreviousSession && (await t.loadPreviousSession(), nextTick(() => {
        re.emit("scrollToBottom");
      }));
    }
    function l() {
      re.emit("close");
    }
    return onMounted(async () => {
      await a(), !s.showWelcomeScreen && !o.value && await c();
    }), (u, p) => (openBlock(), createBlock(gi, { class: "chat-wrapper" }, {
      header: withCtx(() => [
        createBaseVNode("div", z8, [
          createBaseVNode("h1", null, toDisplayString(unref(e)("title")), 1),
          i.value ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: "chat-close-button",
            title: unref(e)("closeButtonTooltip"),
            onClick: l
          }, [
            createVNode(unref(Qs), {
              height: "18",
              width: "18"
            })
          ], 8, U8)) : createCommentVNode("", true)
        ]),
        unref(e)("subtitle") ? (openBlock(), createElementBlock("p", H8, toDisplayString(unref(e)("subtitle")), 1)) : createCommentVNode("", true)
      ]),
      footer: withCtx(() => [
        unref(o) ? (openBlock(), createBlock(fi, { key: 0 })) : (openBlock(), createBlock(lc, { key: 1 }))
      ]),
      default: withCtx(() => [
        !unref(o) && unref(s).showWelcomeScreen ? (openBlock(), createBlock(nc, {
          key: 0,
          "onClick:button": c
        })) : (openBlock(), createBlock($8, {
          key: 1,
          messages: unref(r)
        }, null, 8, ["messages"]))
      ]),
      _: 1
    }));
  }
});
var V8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var G8 = createBaseVNode("path", {
  fill: "currentColor",
  d: "M12 3c5.5 0 10 3.58 10 8s-4.5 8-10 8c-1.24 0-2.43-.18-3.53-.5C5.55 21 2 21 2 21c2.33-2.33 2.7-3.9 2.75-4.5C3.05 15.07 2 13.13 2 11c0-4.42 4.5-8 10-8"
}, null, -1);
var j8 = [
  G8
];
function Z8(n, e) {
  return openBlock(), createElementBlock("svg", V8, [...j8]);
}
var K8 = { name: "mdi-chat", render: Z8 };
var W8 = {
  viewBox: "0 0 24 24",
  width: "1.2em",
  height: "1.2em"
};
var Y8 = createBaseVNode("path", {
  fill: "currentColor",
  d: "M7.41 8.58L12 13.17l4.59-4.59L18 10l-6 6l-6-6z"
}, null, -1);
var J8 = [
  Y8
];
function X8(n, e) {
  return openBlock(), createElementBlock("svg", W8, [...J8]);
}
var Q8 = { name: "mdi-chevron-down", render: X8 };
var eH = { class: "chat-window-wrapper" };
var nH = { class: "chat-window" };
var tH = defineComponent({
  __name: "ChatWindow",
  setup(n) {
    const e = ref(false);
    function t() {
      e.value = !e.value, e.value && nextTick(() => {
        re.emit("scrollToBottom");
      });
    }
    return (r, o) => (openBlock(), createElementBlock("div", eH, [
      createVNode(Transition, { name: "chat-window-transition" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", nH, [
            createVNode(ao)
          ], 512), [
            [vShow, e.value]
          ])
        ]),
        _: 1
      }),
      createBaseVNode("div", {
        class: "chat-window-toggle",
        onClick: t
      }, [
        createVNode(Transition, {
          name: "chat-window-toggle-transition",
          mode: "out-in"
        }, {
          default: withCtx(() => [
            e.value ? (openBlock(), createBlock(unref(Q8), {
              key: 1,
              height: "32",
              width: "32"
            })) : (openBlock(), createBlock(unref(K8), {
              key: 0,
              height: "32",
              width: "32"
            }))
          ]),
          _: 1
        })
      ])
    ]));
  }
});
var rH = defineComponent({
  __name: "App",
  props: {},
  setup(n) {
    const { options: e } = Ge(), t = computed(() => e.mode === "fullscreen");
    return onMounted(() => {
      be.registerLanguage("xml", Lr), be.registerLanguage("javascript", Rr);
    }), (r, o) => t.value ? (openBlock(), createBlock(unref(ao), {
      key: 0,
      class: "n8n-chat"
    })) : (openBlock(), createBlock(unref(tH), {
      key: 1,
      class: "n8n-chat"
    }));
  }
});
function sH(n) {
  var o, s;
  const e = {
    ...Fe,
    ...n,
    webhookConfig: {
      ...Fe.webhookConfig,
      ...n == null ? void 0 : n.webhookConfig
    },
    i18n: {
      ...Fe.i18n,
      ...n == null ? void 0 : n.i18n,
      en: {
        ...(o = Fe.i18n) == null ? void 0 : o.en,
        ...(s = n == null ? void 0 : n.i18n) == null ? void 0 : s.en
      }
    },
    theme: {
      ...Fe.theme,
      ...n == null ? void 0 : n.theme
    }
  }, t = e.target ?? Mo;
  typeof t == "string" && Go(t);
  const r = createApp(rH);
  return r.use(jo, e), r.mount(t), r;
}
export {
  sH as createChat
};
//# sourceMappingURL=@n8n_chat.js.map
